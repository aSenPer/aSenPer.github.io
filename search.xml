<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS中的prototype、__proto__与constructor</title>
    <url>/2019/09/08/JS%E4%B8%AD%E7%9A%84prototype%E3%80%81-proto-%E4%B8%8Econstructor/</url>
    <content><![CDATA[<p>​    原文链接 <a href="https://blog.csdn.net/cc18868876837/article/details/81211729" target="_blank" rel="noopener">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>作为一名前端工程师，必须搞懂JS中的prototype、_ _ proto_ _ 与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，_ _ proto_ _ 属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格：_ <em>proto</em> <em>，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为</em> _ proto_ _ ，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({_ _ proto_ _ : null}) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。<br>     现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示：<br>看到这图别怕，让我们一步步剖析，彻底搞懂它们！</p>
<p><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(6).png" alt=""></p>
<p>  图的说明：右下角为图例，红色箭头表示_ _ proto_ _ 属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。</p>
<h3 id="2-proto-属性"><a href="#2-proto-属性" class="headerlink" title="2. _ _ proto _ _ 属性  "></a>2. _ _ proto _ _ 属性  </h3><p>  首先，我们需要牢记两点：①_ _ proto_ _ 和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有_ _ proto_ _ 和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析：</p>
<p><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(5).png" alt=""></p>
<p>  第一，这里我们仅留下 _ <em>proto</em> _ 属性，它是对象所独有的，可以看到_ _ proto_ _ 属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的_ _ proto_ _ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的_ _ proto_ _ 属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过_ _ proto_ _ 属性来连接对象直到null的一条链即为我们所谓的原型链。<br>  其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠_ _ proto_ _ 继承而来的。</p>
<h3 id="3-prototype属性"><a href="#3-prototype属性" class="headerlink" title="3. prototype属性"></a>3. prototype属性</h3><p>  第二，接下来我们看 prototype 属性：</p>
<p>  <img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(4).png" alt=""></p>
<p>prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：f1._ _ proto_ _  === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>
<h3 id="4-constructor属性"><a href="#4-constructor属性" class="headerlink" title="4. constructor属性"></a>4. constructor属性</h3><p>最后，我们来看一下 constructor 属性：<br>    <img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(3).png" alt=""><br>    constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合_ _ proto_ _ 属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。<br><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(2).png" alt=""></p>
<p>  感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过_ _ proto_ _ 在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象._ _ proto_ _  === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过_ _ proto_ _ 找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下：<br><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(1).png" alt=""></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>我们需要牢记两点：①_ _ proto_ _ 和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有_ _ proto_ _ 和constructor属性。<br>_ _ proto_ _ 属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的_ _ proto_ _ 属性所指向的那个对象（父对象）里找，一直找，直到_ _ proto_ _ 属性的终点null，再往上找就相当于在null上取值，会报错。通过_ _ proto_ _ 属性将对象连接起来的这条链路即我们所谓的原型链。<br>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1._ _ proto_ _  === Foo.prototype。<br>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(Person);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器中配置Nginx一个域名访问多个项目</title>
    <url>/2019/04/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E9%85%8D%E7%BD%AENginx%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>服务器配置个人博客和其它项目使其能够根据不同 url 跳转到不同项目，(例如:<em>localhosh://A 项目/，localhosh://B 项目/</em> )因为对服务器和 Nginx 部署了解甚少，在此记录一下</p>
<a id="more"></a>

<h2 id="location-模块的匹配介绍"><a href="#location-模块的匹配介绍" class="headerlink" title="location 模块的匹配介绍"></a>location 模块的匹配介绍</h2><blockquote>
<ol>
<li>”=”前缀指令匹配，如果匹配成功，则停止其他匹配。</li>
<li>普通字符串指令匹配，顺序是从长到短，匹配成功的 location 如果使用^~，则停止其他匹配（正则匹配）。</li>
<li>正则表达式指令匹配，按照配置文件里的顺序，成功就停止其他匹配。</li>
<li>如果第三步中有匹配成功，则使用该结果，否则使用第二步结果。</li>
</ol>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote>
<ol>
<li>匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的 location 顺序是无关紧要的，反正最后 nginx 会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个匹配的正则表达式将停止搜索。</li>
<li>一般情况下，匹配成功了普通字符串 location 后还会进行正则表达式 location 匹配。有两种方法改变这种行为，其一就是使用“=”前缀，这时执行的是严格匹配，并且匹配成功后立即停止其他匹配，同时处理这个请求；另外一种就是使用“^~”前缀，如果把这个前缀用于一个常规字符串那么告诉 nginx 如果路径匹配那么不测试正则表达式。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location = <span class="string">``</span> / uri;</span><br></pre></td></tr></table></figure>

<p>=开头表示精确匹配，只有完全匹配上才能生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ^ (~<span class="string">``</span> / uri);</span><br></pre></td></tr></table></figure>

<p>^~ 开头对 URL 路径进行前缀匹配，并且在正则之前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~ pattern</span><br></pre></td></tr></table></figure>

<p>~开头表示区分大小写的正则匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~* pattern</span><br></pre></td></tr></table></figure>

<p>~*开头表示不区分大小写的正则匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location<span class="string">``</span> / uri;</span><br></pre></td></tr></table></figure>

<p>不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location /</span><br></pre></td></tr></table></figure>

<p>通用匹配，任何未匹配到其它 location 的请求都会匹配到，相当于 switch 中的 default。</p>
<h2 id="alias-和-root-的区别"><a href="#alias-和-root-的区别" class="headerlink" title="alias 和 root 的区别"></a>alias 和 root 的区别</h2><p>在<a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">VUE</a>中也有alias的概念，感觉两者差不多</p>
<ul>
<li>alias 和 root 都是用来指定文件路径的，root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</li>
<li>root的处理结果是：root路径＋location路径</li>
<li>alias的处理结果是：使用alias路径替换location路径</li>
<li>alias是一个目录别名的定义，root则是最上层目录的定义。</li>
<li>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件</li>
<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>
<li>alias只能位于location块中。（root可以不放在location中）</li>
</ul>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> *****</span><br><span class="line"> *****</span><br><span class="line"> # 域名+项目1名称</span><br><span class="line"> location ^~ <span class="regexp">/A/</span> &#123;</span><br><span class="line">   alias /data/A/;</span><br><span class="line"> &#125;</span><br><span class="line"> # 域名+项目2名称</span><br><span class="line"> location ^~ <span class="regexp">/B/</span> &#123;</span><br><span class="line">   alias /data/B/;</span><br><span class="line"> &#125;</span><br><span class="line">    ****</span><br><span class="line">    ****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.nginx.cn/4658.html" target="_blank" rel="noopener">nginx的location、root、alias指令用法和区别</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Node项目部署</title>
    <url>/2019/05/12/Node%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="利用宝塔可以很快的搭建你需要的环境"><a href="#利用宝塔可以很快的搭建你需要的环境" class="headerlink" title="利用宝塔可以很快的搭建你需要的环境"></a>利用宝塔可以很快的搭建你需要的环境</h2><p>安装 ：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html" target="_blank" rel="noopener">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>将你的项目上传到指定的目录</p>
<h2 id="添加网站"><a href="#添加网站" class="headerlink" title="添加网站"></a>添加网站</h2><p><img src="https://img2020.cnblogs.com/blog/1524685/202006/1524685-20200601100634195-561242539.png" alt=""></p>
<h2 id="安装pm2管理器，方便管理你的Node项目和版本"><a href="#安装pm2管理器，方便管理你的Node项目和版本" class="headerlink" title="安装pm2管理器，方便管理你的Node项目和版本"></a>安装pm2管理器，方便管理你的Node项目和版本</h2><p>PM2是Node.js应用程序的生产流程管理器，内置负载均衡。它可以帮助您保持Node应用程序永久活动，重起这些node应用程序也不需要停机，并简化常见的系统管理任务。<br>填写项目跟目录和启动文件,启动你的node服务，也可以自己安装<code>forever</code><br><img src="https://img2020.cnblogs.com/blog/1524685/202006/1524685-20200601100016539-687074251.png" alt=""></p>
<h2 id="设置nginx反向代理"><a href="#设置nginx反向代理" class="headerlink" title="设置nginx反向代理"></a>设置nginx反向代理</h2><p>执行完以上步骤，你会发现并不能正常访问该项目，这时需要用到<strong><a href="/2019/06/01/正向代理和反向代理/">nginx的反向代理</a></strong><br>打开 网站——&gt;设置——&gt;配置文件<br>在 <code>server</code>中添加一个配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意格式，在宝塔中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;&#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样配置会报错</p>
<h3 id="配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加"><a href="#配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加" class="headerlink" title="配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加"></a>配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加</h3>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>a标签target=‘_blank’的安全问题</title>
    <url>/2020/06/12/a%E6%A0%87%E7%AD%BEtarget-%E2%80%98-blank%E2%80%99%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>外链用了 target=”_blank” 结果悲剧了​​​​<br>我们知道，网页里的a标签默认在当前窗口跳转链接地址，如果需要在新窗口打开，需要给 a 标签添加一个target=”_blank”属性。​<br>顺便提下一个有意思的现象，很早之前我就发现，国外网站倾向于在当前页跳转，而国内网站喜欢打开新窗口。不信你们可以去验证下。我不知道这是交互设计上的文化差异，还 是技术上的开发习惯。​<br> 当然，这两种方式各有优缺点。当前页跳转显得操作比较有连贯性，不会贸然打断用户的注意力，也会减少浏览器的窗口（tab 页）数量。但是对于需要反复回到初始页面的场景 来说，就很麻烦了。比如搜索结果页面，通常需要查看对比几个目标地址，保留在多个窗口还是比较方便。​<br> 今天要说的不只是用户体验上的差别，而是涉及安全和性能。​</p>
</blockquote>
<h2 id="安全隐患​"><a href="#安全隐患​" class="headerlink" title="安全隐患​"></a>安全隐患​</h2><p>如果只是加上target=”_blank”，打开新窗口后，新页面能通过window.opener获取到来源页面的window对象，即使跨域也一样。虽然跨域的页面对于这个对象的属性访问有所限制，但还是有漏网之鱼。<br>比如修改window.opener.location的值，指向另外一个地址。你想想看，刚刚还是在某个网站浏览，随后打开了新窗口，结果这个新窗口神不知鬼不觉地把原来的网页地址改了。这个可以用来做什么？钓鱼啊！等你回到那个钓鱼页面，已经伪装成登录页，你可能就稀里糊涂把账号密码输进去了。<br>还有一种玩法，如果你处于登录状态，有些操作可能只是发送一个GET请求就完事了。通过修改地址，就执行了非你本意的操作，其实就是 CSRF 攻击。​</p>
<h2 id="性能问题​"><a href="#性能问题​" class="headerlink" title="性能问题​"></a>性能问题​</h2><p>除了安全隐患外，还有可能造成性能问题。通过target=”_blank”打开的新窗口，跟原来的页面窗口共用一个进程。如果这个新页面执行了一大堆性能不好的 JavaScript 代码，占用了大量系统资源，那你原来的页面也会受到池鱼之殃。​</p>
<h2 id="解决方案​"><a href="#解决方案​" class="headerlink" title="解决方案​"></a>解决方案​</h2><p>尽量不使用target=”_blank”，如果一定要用，需要加上rel=”noopener”或者rel=”noreferrer”。<strong>但是，火狐并不支持这个属性值，火狐浏览器里需要写成rel=”noreferrer”，所以我们可以将两个属性值合并写成rel=”noopener noreferrer”来完整覆盖。</strong>这样新窗口的window.openner就是null了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。​<br>另外，对于通过window.open的方式打开的新页面，可以这样做：​</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yourWindow = <span class="built_in">window</span>.open();</span><br><span class="line">yourWindow.opener = <span class="literal">null</span>;</span><br><span class="line">yourWindow.location = <span class="string">"icon网页链接"</span>;</span><br><span class="line">yourWindow.target = <span class="string">"_blank"</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2019/04/12/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>

<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"> </span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"> </span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"> </span><br><span class="line">注意：</span><br><span class="line">1.第二行分割表头和内容“-”有一个就行，为了对齐，多加了几个</span><br><span class="line">2.文字默认居左，“-”两边加：表示文字居中；“-”右边加：表示文字居右</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​   &#96;&#96;&#96; 语言类型 如 js &#x2F; html &#x2F; php</span><br><span class="line">    代码...</span><br><span class="line">    代码...</span><br><span class="line">    代码...</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>```</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器登录显示version N/A -&gt; N/A is not yet installed</title>
    <url>/2020/06/09/nvm%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>服务器登录显示 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.</span><br><span class="line">You need to run &quot;nvm install N&#x2F;A&quot; to install it before using it</span><br></pre></td></tr></table></figure>
<p>虽然没有影响使用，但看着真的很别扭，强迫证表示一定要干掉它！<br>问题原因看描述就很清楚了，nvm使用了没有安装的node版本，<br>nvm list 查看下node版本列表<br>nvm -v 查看下当前node版本号<br>nvm use 当前node版本号<br>这样就可以了<br>还有一种方法<br>之前服务器安装了宝塔，在宝塔里安装了pm2来管理node,但是在此之前我记得是单独装过node，问题应该是出在这里了😀</p>
]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>JS继承的实现方式</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91JS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>原文链接 <a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">https://www.cnblogs.com/humin/p/4556820.html</a></p>
<p>既然要实现继承，那么首先我们得有一个父类，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p><strong>核心：</strong> 将父类的实例作为子类的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">'cat'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ol>
<p>缺点：</p>
<ol>
<li>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）（详细请看附录代码： 示例1）</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<p>推荐指数：★★（3、4两大致命缺陷）</p>
<p><strong>2017-8-17 10:21:43补充：感谢 <a href="http://home.cnblogs.com/u/1066372/" target="_blank" rel="noopener">MMHS</a> 指出。缺点1中描述有误：可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在<code>new Animal()</code>这样的语句之后执行。</strong></p>
<p><strong>2018-9-10 00:03:45补充：感谢 <a href="https://www.cnblogs.com/lianghaijie-ctw/" target="_blank" rel="noopener">IRVING_J</a> 指出。缺点3中的描述不够充分。更正为：来自原型对象的所有属性被所有实例共享。</strong></p>
<h3 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h3><p><strong>核心：</strong>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>解决了1中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ol>
<p>推荐指数：★★（缺点3）</p>
<h3 id="3、实例继承"><a href="#3、实例继承" class="headerlink" title="3、实例继承"></a>3、实例继承</h3><p><strong>核心：</strong>为父类实例添加新特性，作为子类实例返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal();</span><br><span class="line">  instance.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>,返回的对象具有相同的效果</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ol>
<p>推荐指数：★★</p>
<h3 id="4、拷贝继承"><a href="#4、拷贝继承" class="headerlink" title="4、拷贝继承"></a>4、拷贝继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> animal)&#123;</span><br><span class="line">    Cat.prototype[p] = animal[p];</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>支持多继承</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ol>
<p>推荐指数：★（缺点1）</p>
<h3 id="5、组合继承"><a href="#5、组合继承" class="headerlink" title="5、组合继承"></a>5、组合继承</h3><p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">// 感谢 @学无止境c 的提醒，组合继承也是需要修复构造函数指向的。Cat.prototype.constructor = Cat;</span></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ol>
<p>缺点：</p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<p>推荐指数：★★★★（仅仅多消耗了一点内存）</p>
<h3 id="6、寄生组合继承"><a href="#6、寄生组合继承" class="headerlink" title="6、寄生组合继承"></a>6、寄生组合继承</h3><p><strong>核心：</strong>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line">  <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  Super.prototype = Animal.prototype;</span><br><span class="line">  <span class="comment">//将实例作为子类的原型</span></span><br><span class="line">  Cat.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true感谢 @bluedrink 提醒，该实现没有修复constructor。Cat.prototype.constructor = Cat; // 需要修复下构造函数</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>堪称完美</li>
</ol>
<p>缺点：</p>
<ol>
<li>实现较为复杂</li>
</ol>
<p>推荐指数：★★★★（实现复杂，扣掉一颗星）</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>for、foreach终止循环</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91for%E3%80%81foreach%E7%BB%88%E6%AD%A2%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>foreach 通过 throw   ***  抛出错误  通过 try {}catch(e){}接受错误 根据错误做出判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      list.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(!i.title)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="string">'BreakT'</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.option_type == <span class="number">0</span> || i.option_type == <span class="number">1</span>) &#123;</span><br><span class="line">                i.option.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (!v &amp;&amp; v !== <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="keyword">throw</span> <span class="string">'BreakV'</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                 &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">     uni.showToast(&#123;</span><br><span class="line">          icon: <span class="string">'none'</span>,</span><br><span class="line">          title: e == <span class="string">'BreakT'</span> ? <span class="string">'您有题目未添加标题，请检查'</span> :<span class="string">'您有选项未设置问题，请检查'</span></span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>for循环直接 break</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js去除字符串空格</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91js%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p><strong>( 1 ) replace正则匹配方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">　　去除字符串内所有的空格：str = str.replace(<span class="regexp">/\\s\*/g</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">　　去除字符串内两头的空格：str = str.replace(<span class="regexp">/^\\s\*|\\s\*$/g</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">　　去除字符串内左侧的空格：str = str.replace(<span class="regexp">/^\\s\*/</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">　　去除字符串内右侧的空格：str = str.replace(<span class="regexp">/(\\s\*$)/g</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>　　<strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/\\s\*/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/^\\s\*|\\s\*$/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/^\\s\*/</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6 //输出右侧有空格左侧无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/(\\s\*$)/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">// 6 6//输出左侧有空格右侧无空格</span></span><br></pre></td></tr></table></figure>
<p><strong>( 2 ) str.trim()方法</strong></p>
<p>　　trim()方法是用来删除字符串两端的空白字符并返回，trim方法并不影响原来的字符串本身，它返回的是一个新的字符串。</p>
<p>　　缺陷：只能去除字符串两端的空格，不能去除中间的空格</p>
<p>　　<strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line">　　单独去除左侧空格则使用 str.trimLeft(); <span class="comment">//var str\_1 = str.trimLeft();</span></span><br><span class="line"></span><br><span class="line">　　单独去除右侧空格则使用 str.trimRight();<span class="comment">//var str\_1 = str.trimRight();</span></span><br></pre></td></tr></table></figure>
<p><strong>( 3 ) JQ方法：$.trim(str)方法</strong></p>
<p>　　$.trim() 函数用于去除字符串两端的空白字符。</p>
<p>　　<strong>注意：</strong>$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。</p>
<p>　　<strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = $.trim(str);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br></pre></td></tr></table></figure>
<p>转<a href="https://www.cnblogs.com/a-cat/p/8872498.html" target="_blank" rel="noopener">https://www.cnblogs.com/a-cat/p/8872498.html</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】promise</title>
    <url>/2019/04/20/%E3%80%90JS%E3%80%91promise/</url>
    <content><![CDATA[<h3 id="八段代码彻底掌握-Promise"><a href="#八段代码彻底掌握-Promise" class="headerlink" title="八段代码彻底掌握 Promise"></a>八段代码彻底掌握 Promise</h3><h3 id="原文链接-https-juejin-im-post-597724c26fb9a06bb75260e8"><a href="#原文链接-https-juejin-im-post-597724c26fb9a06bb75260e8" class="headerlink" title="原文链接  https://juejin.im/post/597724c26fb9a06bb75260e8"></a>原文链接  <a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">https://juejin.im/post/597724c26fb9a06bb75260e8</a></h3><h3 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"create a promise"</span></span><br><span class="line"><span class="string">"after new Promise"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure>

<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>
<h3 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);  </span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    reject(<span class="number">3</span>);  </span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p3);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"rejected"</span>, [[PromiseValue]]: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个<code>setTimeout</code>函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h3 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  reject(<span class="string">"reject"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"success1"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure>

<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为<code>success2</code>，p2中<code>reject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>
<h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="string">"resolve"</span></span><br><span class="line"><span class="string">"reject: reject"</span></span><br></pre></td></tr></table></figure>

<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><code>return</code> 一个同步的值 ，或者 <code>undefined</code>（当没有返回一个有效值时，默认返回undefined），<code>then</code>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><code>return</code> 另一个 Promise，<code>then</code>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
<li><code>throw</code> 一个同步异常，<code>then</code>方法将返回一个rejected状态的Promise, 值是该异常。</li>
</ul>
<p>根据以上分析，代码中第一个<code>then</code>会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个<code>then</code>输出的值是2。第二个<code>then</code>中没有返回值，因此将返回默认的undefined，于是在第三个<code>then</code>中输出undefined。第三个<code>then</code>和第四个<code>then</code>中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个<code>then</code>中成功的回调函数和第五个<code>then</code>中失败的回调函数处理。</p>
<h3 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;which one is called first ?&#39;</span><br><span class="line">&#39;success&#39;</span><br></pre></td></tr></table></figure>

<p>Promise接收的函数参数是同步执行的，但<code>then</code>方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h3 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve( <span class="number">1</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve( <span class="number">2</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</span><br><span class="line">    foo.bar();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1 then err: <span class="built_in">ReferenceError</span>: foo is not defined</span><br><span class="line">p2 then value: <span class="number">2</span></span><br><span class="line">p1 then then value: <span class="literal">undefined</span></span><br><span class="line">p2 then then err: <span class="built_in">ReferenceError</span>: foo is not defined</span><br><span class="line">p2 then then then value: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Promise中的异常由<code>then</code>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<code>then</code>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<code>then</code>的回调函数是交替执行的 ，这正是由Promise <code>then</code>回调的异步性决定的。</p>
<h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">p2=<span class="number">1</span></span><br><span class="line">p1=<span class="number">1</span></span><br><span class="line">p4=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<code>then</code>最先调用，但在控制台上是最后输出结果的呢？因为p4的<code>resolve</code>中接收的参数是一个Promise对象p1，<code>resolve</code>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h3 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p3 rejected: [object <span class="built_in">Promise</span>]</span><br><span class="line">p1 fulfilled: resolve</span><br><span class="line">p2 rejected: reject</span><br></pre></td></tr></table></figure>

<p>Promise回调函数中的第一个参数<code>resolve</code>，会对Promise执行”拆箱”动作。即当<code>resolve</code>的参数是一个Promise对象时，<code>resolve</code>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此<code>fulfilled</code>回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此<code>rejected</code>回调被执行。但Promise回调函数中的第二个参数<code>reject</code>不具备”拆箱“的能力，reject的参数会直接传递给<code>then</code>方法中的<code>rejected</code>回调。因此，即使p3 <code>reject</code>接收了一个resolved状态的Promise，<code>then</code>方法中被调用的依然是<code>rejected</code>，并且参数就是<code>reject</code>接收到的Promise对象。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】作用域链与原型链</title>
    <url>/2019/04/20/%E3%80%90JS%E3%80%91%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>原文链接 <a href="https://www.cnblogs.com/pssp/p/5204324.html" target="_blank" rel="noopener">https://www.cnblogs.com/pssp/p/5204324.html</a></p>
<h3 id="什么是作用域链，什么是原型链。"><a href="#什么是作用域链，什么是原型链。" class="headerlink" title="什么是作用域链，什么是原型链。"></a>什么是作用域链，什么是原型链。</h3><p>　　作用域是针对变量的，比如我们创建了一个函数，函数里面又包含了一个函数，那么现在就有三个作用域</p>
<p>　　全局作用域==&gt;函数1作用域==&gt;函数2作用域</p>
<p>作用域的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>



<p>最后打印出来的是3，因为执行函数c（）的时候它在自己的范围内找到了变量a所以就不会越上继续查找，如果在函数c()中没有找到则会继续向上找，一直会找到全局变量a，这个查找的过程就叫作用域链。</p>
<p>不知道你有没有疑问，函数c为什么可以在函数b中查找变量a，因为函数c是在函数b中创建的，也就是说函数c的作用域包括了函数b的作用域，当然也包括了全局作用域，但是函数b不能向函数c中查找变量，因为作用域只会向上查找。</p>
<p>那么什么是原型链呢？</p>
<p>　　原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的属性，然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。</p>
<p>　　Object ==&gt; 构造函数1 ==&gt; 构造函数2</p>
<p>　　就和css中的继承一样，如果自身没有定义就会继承父元素的样式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">a.prototype.name = <span class="string">"追梦子"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> a();</span><br><span class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】判断客户端类型</title>
    <url>/2019/05/22/%E3%80%90JS%E3%80%91%E5%88%A4%E6%96%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JS-判断客户端是iOS还是Android"><a href="#JS-判断客户端是iOS还是Android" class="headerlink" title="JS 判断客户端是iOS还是Android"></a>JS 判断客户端是iOS还是Android</h1><blockquote>
<p>判断的逻辑是：客户端不是Android，就是iOS，就是PC，其实还有黑莓BlackBerry、塞班SymbianOS、Windows Phone等，如果需要可自行添加，我在第三条有写。</p>
</blockquote>
<h2 id="通过浏览器的-navigator-userAgent-判断是Android还是iOS："><a href="#通过浏览器的-navigator-userAgent-判断是Android还是iOS：" class="headerlink" title="通过浏览器的 navigator.userAgent 判断是Android还是iOS："></a>通过浏览器的 navigator.userAgent 判断是Android还是iOS：</h2><h3 id="一-判断是Android还是iOS"><a href="#一-判断是Android还是iOS" class="headerlink" title="一. 判断是Android还是iOS"></a>一. 判断是Android还是iOS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">let</span> isAndroid = u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>;   <span class="comment">//判断是否是 android终端</span></span><br><span class="line"><span class="keyword">let</span> isIOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);     <span class="comment">//判断是否是 iOS终端</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'是否是Android：'</span>, isAndroid); <span class="comment">//true,false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'是否是iOS：'</span>, isIOS)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>封装成方法：</p>
<p>``  /<em>判断客户端</em>/<br>  judgeClient() {</p>
<pre><code>let u = navigator.userAgent;
let isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Adr&apos;) &gt; -1;   //判断是否是 android终端
let isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);     //判断是否是 iOS终端
console.log(&apos;是否是Android：&apos; + isAndroid); //true,false
console.log(&apos;是否是iOS：&apos; + isIOS);
if(isAndroid){
  return &apos;Android&apos;;
}else if(isIOS){
  return &apos;IOS&apos;;
}else{
  return &apos;PC&apos;;
}</code></pre><p>  },```</p>
</li>
</ul>
<h3 id="二-判断是Android还是iOS"><a href="#二-判断是Android还是iOS" class="headerlink" title="二.判断是Android还是iOS"></a>二.判断是Android还是iOS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(iPhone|iPad|iPod|iOS)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isIOS'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/(Android)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isAndroid'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isPC'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">*   封装成方法：</span><br><span class="line">      <span class="comment">/*判断客户端*/</span></span><br><span class="line">      judgeClient() &#123;</span><br><span class="line">        <span class="keyword">let</span> client = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/(iPhone|iPad|iPod|iOS)/i</span>.test(navigator.userAgent)) &#123;  <span class="comment">//判断iPhone|iPad|iPod|iOS</span></span><br><span class="line">          client = <span class="string">'iOS'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/(Android)/i</span>.test(navigator.userAgent)) &#123;  <span class="comment">//判断Android</span></span><br><span class="line">          client = <span class="string">'Android'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          client = <span class="string">'PC'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="三-判断PC还是移动端"><a href="#三-判断PC还是移动端" class="headerlink" title="三.判断PC还是移动端"></a>三.判断PC还是移动端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isPC() &#123;</span><br><span class="line">  <span class="comment">/*true则pc，false则mobile*/</span></span><br><span class="line">  <span class="keyword">let</span> u = navigator.userAgent;</span><br><span class="line">  <span class="keyword">let</span> Agents = [<span class="string">"Android"</span>, <span class="string">"iPhone"</span>, <span class="string">"webOS"</span>, <span class="string">"BlackBerry"</span>, <span class="string">"SymbianOS"</span>, <span class="string">"Windows Phone"</span>, <span class="string">"iPad"</span>, <span class="string">"iPod"</span>];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; Agents.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (u.indexOf(Agents[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<h3 id="四-判断多种访问终端"><a href="#四-判断多种访问终端" class="headerlink" title="四.判断多种访问终端"></a>四.判断多种访问终端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//判断访问终端</span></span><br><span class="line">    <span class="keyword">let</span> browser = &#123;</span><br><span class="line">      versions: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          trident: u.indexOf(<span class="string">'Trident'</span>) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span><br><span class="line">          presto: u.indexOf(<span class="string">'Presto'</span>) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span><br><span class="line">          webKit: u.indexOf(<span class="string">'AppleWebKit'</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">          gecko: u.indexOf(<span class="string">'Gecko'</span>) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(<span class="string">'KHTML'</span>) == <span class="number">-1</span>,<span class="comment">//火狐内核</span></span><br><span class="line">          mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">          ios: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">          android: u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>, <span class="comment">//android终端</span></span><br><span class="line">          iPhone: u.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">          iPad: u.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">          webApp: u.indexOf(<span class="string">'Safari'</span>) == <span class="number">-1</span>, <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">          weixin: u.indexOf(<span class="string">'MicroMessenger'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否微信</span></span><br><span class="line">          qq: u.match(<span class="regexp">/\sQQ/i</span>) == <span class="string">" qq"</span> <span class="comment">//是否QQ</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;(),</span><br><span class="line">      language: (navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (browser.versions.mobile) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"is mobile"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (browser.versions.ios) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"is ios"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="五-判断浏览器当前使用的语言"><a href="#五-判断浏览器当前使用的语言" class="headerlink" title="五.判断浏览器当前使用的语言"></a>五.判断浏览器当前使用的语言</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">judgeLanguage() &#123;</span><br><span class="line">  <span class="comment">// 判断浏览器当前使用的语言</span></span><br><span class="line">  <span class="keyword">let</span> currentLanguage = (navigator.browserLanguage || navigator.language).toLowerCase();    <span class="comment">// 非IE</span></span><br><span class="line">  <span class="keyword">if</span> (!currentLanguage) &#123;    <span class="comment">// IE浏览器</span></span><br><span class="line">    currentLanguage = navigator.browserLanguage;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(currentLanguage);</span><br><span class="line">  <span class="keyword">return</span> currentLanguage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】判断数据类型的方法</title>
    <url>/2019/05/20/%E3%80%90JS%E3%80%91%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对js中不同数据的布尔值类型总结：false:空字符串；null；undefined；0；NaN。<br>true：除了上面的false的情况其他都为true；</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkBoolean</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(a)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="string">''</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="literal">null</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="literal">undefined</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="literal">NaN</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(a));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(c));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>javascript中有六种数据类型：string；boolean；Array；Object；null;undefined。如何检测这些数据类型呢，总结方法如下：</p>
<p><strong>方法一：采用typeof</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = \[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>\];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">123</span>,</span><br><span class="line">    b:<span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;       <span class="keyword">var</span> u = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">//方法一使用typeof方法。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);<span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);<span class="comment">//null是一个空的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn);<span class="comment">//function</span></span><br></pre></td></tr></table></figure>


<p>通过上面的检测我们发现typeof检测的Array和Object的返回类型都是Object，因此用typeof是无法检测出来数组和对象的，采用方法二和方法三则可以检测出来。</p>
<p><strong>方法二：instanceof</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//  false</span></span><br></pre></td></tr></table></figure>


<p> 注意：instaceof只可以用来判断数组和对象，不能判断string和boolean类型，要判断string和boolean类型需要采用方法四。<br> 由于数组也属于对象因此我们使用instanceof判断一个数组是否为对象的时候结果也会是true。如：</p>
<p>console.log(a instanceof Object);//true。</p>
<p>下面封装一个方法进行改进：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="keyword">var</span> getDataType = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Array'</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( o <span class="keyword">instanceof</span> <span class="built_in">Object</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Object'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'param is no object type'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getDataType(o));<span class="comment">//Object。</span></span><br><span class="line"><span class="built_in">console</span>.log(getDataType(a));<span class="comment">//Array。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用constructor方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">           <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor == <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.constructor == <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>方法四：利用tostring()方法，这个方法是最佳的方案。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> c(<span class="string">'kingw'</span>,<span class="string">'27'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a));<span class="comment">//\[object Array\]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(o));<span class="comment">//\[Object Object\]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(c));<span class="comment">//\[Object Object\]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个方法判断数组和对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> type = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">       <span class="keyword">if</span>(type == <span class="string">'\[object Array\]'</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">'Array'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">'\[object Object\]'</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"Object"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">'param is no object type'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isType(o));<span class="comment">//Object</span></span><br><span class="line"><span class="built_in">console</span>.log(isType(a));<span class="comment">//Array</span></span><br></pre></td></tr></table></figure>

<p><strong>方法五：利用jquery的$.isPlainObject();$.isArray(obj);$.isFunction(obj)进行判断。</strong></p>
<p> 出处：<a href="http://www.cnblogs.com/xinggood" target="_blank" rel="noopener">http://www.cnblogs.com/xinggood</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收内存泄漏</title>
    <url>/2019/05/02/%E3%80%90JS%E3%80%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><ol>
<li>分配你所需要的内存：</li>
</ol>
<p>由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会<strong>分配内存来存储那个实体</strong>。</p>
<ol start="2">
<li><p>使用分配到的内存做点什么。</p>
</li>
<li><p>不需要时将其释放回归：</p>
</li>
</ol>
<p>在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是<strong>垃圾回收机制所存在的意义</strong>。</p>
<p><strong>所谓的内存泄漏指的是</strong>：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>在C和C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。</p>
<h3 id="垃圾收集机制的原理"><a href="#垃圾收集机制的原理" class="headerlink" title="垃圾收集机制的原理"></a>垃圾收集机制的原理</h3><p><strong>垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存</strong>。</p>
<p><strong>什么叫不再继续使用的变量？</strong></p>
<p>不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</p>
<p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说<strong>全局变量不会被当成垃圾回收</strong>。</p>
<h3 id="标记清除：当前采用的垃圾收集策略"><a href="#标记清除：当前采用的垃圾收集策略" class="headerlink" title="标记清除：当前采用的垃圾收集策略"></a>标记清除：当前采用的垃圾收集策略</h3><p>工作原理：</p>
<p>当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
<p>工作流程：</p>
<ol>
<li>垃圾收集器会在运行的时候会给存储在内存中的<strong>所有变量都加上标记</strong>。</li>
<li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>
<li>那些还存在标记的变量被视为准备删除的变量。</li>
<li>最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<p>到2008年为止,IE、Chorme、Fireofx、Safari、Opera <strong>都使用标记清除式的垃圾收集策略</strong>，只不过垃圾收集的时间间隔互有不同。</p>
<h3 id="引用计数略：被废弃的垃圾收集策"><a href="#引用计数略：被废弃的垃圾收集策" class="headerlink" title="引用计数略：被废弃的垃圾收集策"></a>引用计数略：被废弃的垃圾收集策</h3><p>循环引用：跟踪记录每个值被引用的技术</p>
<p>在老版本的浏览器中(对，又是IE)，IE9以下BOM和DOM对象就是使用C++以COM对象的形式实现的。</p>
<p>COM的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'something'</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element; <span class="comment">// element属性指向dom</span></span><br><span class="line">element.someThing = myObject; <span class="comment">// someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。</span></span><br></pre></td></tr></table></figure>
<p>解决方式是，当我们不使用它们的时候，手动切断链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>; </span><br><span class="line">element.someThing = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><strong>淘汰</strong>：</p>
<p>IE9把BOM和DOM对象转为了真正的js对象，避免了使用这种垃圾收集策略，消除了IE9以下常见的内存泄漏的主要原因。</p>
<p>IE7以下有一个声明狼藉的性能问题，大家了解一下：</p>
<ol>
<li>256个变量，4096个对象(或数组)字面或者64KB的字符串，达到任何一个临界值会触发垃圾收集器运行。</li>
<li>如果一个js脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。</li>
</ol>
<p>IE7已修复这个问题。</p>
<h2 id="哪些情况会引起内存泄漏"><a href="#哪些情况会引起内存泄漏" class="headerlink" title="哪些情况会引起内存泄漏"></a>哪些情况会引起内存泄漏</h2><p>虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。</p>
<h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><p>上文我们提到了<strong>全局变量不会被当成垃圾回收</strong>，我们在编码中有时会出现下面这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.bar2 = <span class="string">'默认绑定this指向全局'</span> <span class="comment">// 全局变量=&gt; window.bar2</span></span><br><span class="line">  bar = <span class="string">'全局变量'</span>; <span class="comment">// 没有声明变量 实际上是全局变量=&gt;window.bar</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>当我们使用<a href="https://juejin.im/post/5b3715def265da59af40a630#heading-3" target="_blank" rel="noopener">默认绑定</a>，this会指向全局，<code>this.something</code>也会创建一个全局变量，这一点可能很多人没有注意到。</p>
<p><strong>解决方法：在函数内使用严格模式or细心一点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>; </span><br><span class="line">  <span class="keyword">this</span>.bar2 = <span class="string">"严格模式下this指向undefined"</span>; </span><br><span class="line">  bar = <span class="string">"报错"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>当然我们也可以<strong>手动释放全局变量的内存</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.bar = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.bar2</span><br></pre></td></tr></table></figure>
<h3 id="被遗忘的定时器和回调函数"><a href="#被遗忘的定时器和回调函数" class="headerlink" title="被遗忘的定时器和回调函数"></a>被遗忘的定时器和回调函数</h3><p>当<strong>不需要</strong><code>setInterval</code>或者<code>setTimeout</code>时，<strong>定时器没有被clear</strong>，定时器的<strong>回调函数以及内部依赖的变量都不能被回收</strong>，造成内存泄漏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">        <span class="comment">// 定时器也没有清除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node、someResource 存储了大量数据 无法回收</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>： 在定时器完成工作的时候，手动清除定时器。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(obj,<span class="string">'闭包内引用obj obj不会被释放'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// obj = null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：手动解除引用，<code>obj = null</code>。</p>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>就是IE9以下的循环引用问题，上文讲过了。</p>
<h3 id="没有清理DOM元素引用"><a href="#没有清理DOM元素引用" class="headerlink" title="没有清理DOM元素引用"></a>没有清理DOM元素引用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">'refA'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">"refA"</span>);  <span class="comment">// 但是还存在引用 能console出整个div 没有被回收</span></span><br></pre></td></tr></table></figure>
<p>不信的话，可以看下这个<a href="https://codepen.io/OBKoro1/pen/vroKbg" target="_blank" rel="noopener">dom</a>。</p>
<p><strong>解决办法</strong>：refA = null;</p>
<h3 id="console保存大量数据在内存中"><a href="#console保存大量数据在内存中" class="headerlink" title="console保存大量数据在内存中"></a>console保存大量数据在内存中</h3><p>过多的console，比如定时器的console会导致浏览器卡死。</p>
<p><strong>解决</strong>：合理利用console，线上项目尽量少的使用console，当然如果你要发招聘，除外。</p>
<h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p><strong>记住一个原则：不用的东西，及时归还，毕竟你是’借的’嘛</strong>。</p>
<ol>
<li>减少不必要的全局变量，使用严格模式避免意外创建全局变量。</li>
<li>在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。</li>
<li>组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</li>
</ol>
<h3 id="关于内存泄漏"><a href="#关于内存泄漏" class="headerlink" title="关于内存泄漏"></a>关于内存泄漏</h3><ol>
<li>即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。</li>
<li>一般是堆区内存泄漏，栈区不会泄漏。</li>
</ol>
<p>基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以<strong>对象、数组之类的，才会发生内存泄漏</strong>。</p>
<ol start="3">
<li>使用chorme监控内存泄漏</li>
</ol>
<p>转自<a href="http://obkoro1.com/" target="_blank" rel="noopener">http://obkoro1.com/</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的正则表达式</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> . 校验密码强度</span><br><span class="line">密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="number">8</span><span class="number">-10</span>之间。</span><br><span class="line">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 校验中文</span><br><span class="line">字符串仅能是中文。</span><br><span class="line">^[\\u4e00-\\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 由数字、<span class="number">26</span>个英文字母或下划线组成的字符串</span><br><span class="line">^\\w+$</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 校验E-Mail 地址</span><br><span class="line">同密码一样，下面是E-mail地址合规性的正则检查语句。</span><br><span class="line">[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 校验身份证号码</span><br><span class="line">下面是身份证号码的正则校验。<span class="number">15</span> 或 <span class="number">18</span>位。</span><br><span class="line"><span class="number">15</span>位：</span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">18</span>位：</span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;([<span class="number">0</span><span class="number">-9</span>]|X)$</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 校验日期</span><br><span class="line">“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</span><br><span class="line">^(?:(?!<span class="number">0000</span>)[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">4</span>&#125;-(?:(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-8</span>])|(?:<span class="number">0</span>[<span class="number">13</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">29</span>|<span class="number">30</span>)|(?:<span class="number">0</span>[<span class="number">13578</span>]|<span class="number">1</span>[<span class="number">02</span>])<span class="number">-31</span>)|(?:[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])|(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])<span class="number">00</span>)<span class="number">-02</span><span class="number">-29</span>)$</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 校验金额</span><br><span class="line">金额校验，精确到<span class="number">2</span>位小数。</span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 校验手机号</span><br><span class="line">下面是国内 <span class="number">13</span>、<span class="number">15</span>、<span class="number">18</span>开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</span><br><span class="line">^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 判断IE的版本</span><br><span class="line">IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</span><br><span class="line">^.*MSIE [<span class="number">5</span><span class="number">-8</span>](?:\\.[<span class="number">0</span><span class="number">-9</span>]+)?(?!.*Trident\\/[<span class="number">5</span><span class="number">-9</span>]\\<span class="number">.0</span>).*$</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 校验IP-v4地址</span><br><span class="line">IP4 正则语句。</span><br><span class="line">\\b(?:(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)\\.)&#123;<span class="number">3</span>&#125;(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)\\b</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> 校验IP-v6地址</span><br><span class="line">IP6 正则语句。</span><br><span class="line">(([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;|[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;)|:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;|:)|fe80:(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">0</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">4</span>&#125;%[<span class="number">0</span><span class="number">-9</span>a-zA-Z]&#123;<span class="number">1</span>,&#125;|::(ffff(:<span class="number">0</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;:)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>]))</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> 检查URL的前缀</span><br><span class="line">应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</span><br><span class="line"><span class="keyword">if</span> (!s.match(<span class="regexp">/^[a-zA-Z]+:\\/</span>\\<span class="comment">//))</span></span><br><span class="line">&#123;</span><br><span class="line">    s = <span class="string">'http://'</span> + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 提取URL链接</span><br><span class="line">下面的这个表达式可以筛选出一段文本中的URL。</span><br><span class="line">^(f|ht)&#123;<span class="number">1</span>&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> 文件路径及扩展名校验</span><br><span class="line">验证windows下文件路径和扩展名（下面的例子中为.txt文件）</span><br><span class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?<span class="string">"&lt;&gt;|]+\\.txt(l)?$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">15. 提取Color Hex  Codes</span></span><br><span class="line"><span class="string">有时需要抽取网页中的颜色代码，可以使用下面的表达式。</span></span><br><span class="line"><span class="string">^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">16. 提取网页图片</span></span><br><span class="line"><span class="string">假若你想提取网页中所有图片信息，可以利用下面的表达式。</span></span><br><span class="line"><span class="string">\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\"</span>\\<span class="string">']&#123;0,1&#125;([^\\"\\'</span>\\ &gt;]*)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> 提取页面超链接</span><br><span class="line">提取html中的超链接。</span><br><span class="line">(<span class="xml"><span class="tag">&lt;<span class="name">a\\s*(?!.*\\brel=)[^</span>&gt;</span>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">18. 查找CSS属性</span></span><br><span class="line"><span class="xml">通过下面的表达式，可以搜索到相匹配的CSS属性。</span></span><br><span class="line"><span class="xml">^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">19. 抽取注释</span></span><br><span class="line"><span class="xml">如果你需要移除HMTL中的注释，可以使用如下的表达式。</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--(.*?)--&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">20. 匹配HTML标签</span></span><br><span class="line"><span class="xml">通过下面的表达式可以匹配出HTML中的标签属性。</span></span><br><span class="line">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'"&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】监听页面的后退返回(移动端PC端)</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%90%8E%E9%80%80%E8%BF%94%E5%9B%9E(%E7%A7%BB%E5%8A%A8%E7%AB%AFPC%E7%AB%AF)/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">pushHistory</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> state = &#123;</span><br><span class="line">            title: <span class="string">"title"</span>,</span><br><span class="line">            url: <span class="string">"#"</span> &#125;;</span><br><span class="line">        <span class="built_in">window</span>.history.pushState(state, <span class="string">"title"</span>, <span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushHistory();</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"popstate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"我监听到了浏览器的返回按钮事件啦"</span>); <span class="comment">// 根据自己的需求实现自己的功能</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(o) <span class="keyword">return</span> &#123;</span><br><span class="line">  fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123; <span class="keyword">return</span> fun(m,n);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; <span class="keyword">var</span> a = fun(<span class="number">0</span>); a.fun(<span class="number">1</span>); a.fun(<span class="number">2</span>); a.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>); c.fun(<span class="number">2</span>); c.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,? //问:三行a,b,c的输出分别是什么？</span></span><br></pre></td></tr></table></figure>

<p>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</p>
<p>可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？</p>
<p><strong>答案</strong></p>
<p>//a: undefined,0,0,0 //b: undefined,0,1,2 //c: undefined,0,1,1</p>
<p>都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了；如果没有答案，继续往下分析。</p>
<p><strong>JS中有几种函数</strong></p>
<p>首先，在此之前需要了解的是，在JS中函数可以分为两种，具名函数（命名函数）和匿名函数。</p>
<p>区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数</p>
<p><strong>注意：</strong>在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试</p>
<p>或是采用兼容IE的获取函数name方法来获取函数名称：</p>
<p>/**<br>  * 获取指定函数的函数名称（用于兼容IE）<br>  * @param {Function} fun 任意函数 */<br>function getFunctionName(fun) { if (fun.name !== undefined) return fun.name; var ret = fun.toString();<br>  ret = ret.substr(‘function ‘.length);<br>  ret = ret.substr(0, ret.indexOf(‘(‘)); return ret;<br>}</p>
<p>遂用上述函数测试是否为匿名函数：</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161154422.png?2015102516123" alt=""></p>
<p>可以得知变量fn1是具名函数，fn2是匿名函数</p>
<p><strong>创建函数的几种方式</strong></p>
<p>说完函数的类型，还需要了解JS中创建函数都有几种创建方法。</p>
<p><strong>1、声明函数</strong></p>
<p>最普通最标准的声明函数方法，包括函数名及函数体。</p>
<p><strong>function fn1(){}</strong></p>
<p><strong>2、创建匿名函数表达式</strong></p>
<p>创建一个变量，这个变量的内容为一个函数</p>
<p><strong>var fn1=function (){}</strong><br>注意采用这种方法创建的函数为匿名函数，即没有函数name</p>
<p>var fn1=function (){};<br>getFunctionName(fn1).length;//0</p>
<p><strong>3、创建具名函数表达式</strong></p>
<p>创建一个变量，内容为一个带有名称的函数</p>
<p><strong>var fn1=function xxcanghai(){};</strong><br><strong>注意：</strong>具名函数表达式的函数名只能在创建函数内部使用</p>
<p>即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用</p>
<p>测试：</p>
<p>var fn1=function xxcanghai(){<br>  console.log(“in:fn1&lt;”,typeof fn1,”&gt;xxcanghai:&lt;”,typeof xxcanghai,”&gt;”);<br>};<br>console.log(“out:fn1&lt;”,typeof fn1,”&gt;xxcanghai:&lt;”,typeof xxcanghai,”&gt;”);<br>fn1(); //out:fn1&lt; function &gt;xxcanghai:&lt; undefined &gt; //in:fn1&lt; function &gt;xxcanghai:&lt; function &gt;</p>
<p>可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。</p>
<p><strong>注意：</strong>在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</p>
<p><strong>4、Function构造函数</strong></p>
<p>可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是匿名函数。</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161355276.png?2015102516143" alt=""></p>
<p><strong>5、自执行函数</strong></p>
<p>(function(){alert(1);})();<br>(function fn1(){alert(1);})();</p>
<p>自执行函数属于上述的“函数表达式”，规则相同</p>
<p> <strong>6、其他创建函数的方法</strong></p>
<p>当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 <strong>eval ， setTimeout ， setInterval</strong> 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开</p>
<p><strong>三个fun函数的关系是什么？</strong></p>
<p>说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。</p>
<p>这段代码中出现了三个fun函数，所以第一步先搞清楚，这三个fun函数的关系，哪个函数与哪个函数时相同的。</p>
<p>function fun(n,o) {<br> console.log(o) return {<br>  fun:function(m){ //…<br> }<br> };<br>}</p>
<p>先看第一个fun函数，属于标准具名函数声明，是新创建的函数，他的返回值是一个对象字面量表达式，属于一个新的object。</p>
<p>这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。</p>
<p><strong>注意：</strong>所有声明的匿名函数都是一个新函数。</p>
<p>所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。</p>
<p><strong>函数作用域链的问题</strong></p>
<p>再说第三个fun函数之前需要先说下，在函数表达式内部能不能访问存放当前函数的变量。</p>
<p><strong>测试1：对象内部的函数表达式：</strong></p>
<p>var o={<br> fn:function (){<br>  console.log(fn);<br> }<br>};<br>o.fn();//ERROR报错</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161534228.png?20151025161556" alt=""></p>
<p><strong>测试2：非对象内部的函数表达式：</strong></p>
<p>var fn=function (){<br> console.log(fn);<br>};<br>fn();//function (){console.log(fn);};正确</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161644557.png?20151025161652" alt=""></p>
<p><strong>结论：</strong>使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。</p>
<p>原因也非常简单，因为函数作用域链的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。</p>
<p>所以综上所述，可以得知，最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。</p>
<p>所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。</p>
<p><strong>到底在调用哪个函数？</strong></p>
<p>再看下原题，现在知道了程序中有两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？</p>
<p>function fun(n,o) {<br> console.log(o) return {<br>  fun:function(m){ return fun(m,n);<br>  }<br> };<br>} var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined,?,?,?<br>var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?<br>var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,? //问:三行a,b,c的输出分别是什么？</p>
<p><strong>1、第一行a</strong></p>
<p>*<em>var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);<br>*</em>可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：</p>
<p>第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用fun(0)时，o为undefined；</p>
<p>第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0</p>
<p>第四次同理；</p>
<p>即：最终答案为undefined,0,0,0</p>
<p><strong>2、第二行b</strong></p>
<p>*<em>var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?<br>*</em>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；</p>
<p>第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；</p>
<p>即最终答案：undefined,0,1,2</p>
<p> <strong>3、第三行c</strong></p>
<p>*<em>var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?<br>*</em>根据前面两个例子，可以得知：</p>
<p>fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；</p>
<p>第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1</p>
<p>即最终答案：undefined,0,1,1</p>
<p>后话</p>
<p>这段代码原本是在做一个将异步回调改写为同步调用的组件时的代码，发现了这个坑，对JS的闭包有了更深入的了解。</p>
<p>关于什么是闭包，网上的文章数不胜数，但理解什么是闭包还是要在代码中自己去发现与领悟。</p>
<p>如果要我说什么是闭包，我认为，广义上的闭包就是指一个变量在他自身作用域的被使用了，就叫发生了闭包。</p>
<p>转      <a href="https://www.jb51.net/article/75450.htm" target="_blank" rel="noopener">https://www.jb51.net/article/75450.htm</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】vuecli3 favicon 的修改</title>
    <url>/2019/04/20/%E3%80%90Vue%E3%80%91vuecli3%20favicon%20%E7%9A%84%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>在vue.config.js中配置pwa，重跑下项目就行了 // 以下是pwa配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pwa: &#123;</span><br><span class="line">     iconPaths: &#123;</span><br><span class="line">       favicon32     : <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       favicon16     : <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       appleTouchIcon: <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       maskIcon      : <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       msTileImage   : <span class="string">'faviconfc.ico'</span> &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】关于 vue动态绑定class的几种方式</title>
    <url>/2019/04/20/%E3%80%90Vue%E3%80%91%E5%85%B3%E4%BA%8E%20vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>###对象方法<br>-最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）</p>
<p>：class=“{‘active’:isTrue}”</p>
<p>判断是否绑定一个active</p>
<p>:class=“{‘active’:isActive==-1}” 或者<br>:class=“{‘active’:isActive==index}”</p>
<p>绑定并判断多个</p>
<p>第一种（用逗号隔开）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; 'active': isActive, 'sort': isSort &#125;"</span></span><br></pre></td></tr></table></figure>
<p>第二种（放在data里面）<br>//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span> data() &#123; <span class="keyword">return</span> &#123;</span><br><span class="line">        classObject:&#123; <span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">sort</span>:<span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种（使用computed属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span> data() &#123; <span class="keyword">return</span> &#123;</span><br><span class="line">        isActive: <span class="literal">true</span>,</span><br><span class="line">        isSort: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">    classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;</span><br><span class="line">          active: <span class="keyword">this</span>.isActive,</span><br><span class="line">          sort:<span class="keyword">this</span>.isSort</span><br><span class="line">       &#125;</span><br><span class="line">          </span><br><span class="line">　　&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">###数组方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单纯数组</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"\[isActive,isSort\]"</span> data() &#123; <span class="keyword">return</span>&#123;</span><br><span class="line">    isActive:<span class="string">'active'</span>,</span><br><span class="line">    isSort:<span class="string">'sort'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组与三元运算符结合判断选择需要的class<br>（注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"\[isActive?'active':''\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[isActive==1?'active':''\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[isActive==index?'active':''\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[isActive==index?'active':'otherActiveClass'\]"</span></span><br></pre></td></tr></table></figure>
<p>数组对象结合动态判断<br>//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p>
<p>//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"\[&#123; active: isActive &#125;, 'sort'\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[&#123; active: isActive==1 &#125;, 'sort'\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[&#123; active: isActive==index &#125;, 'sort'\]"</span></span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/qq\_43077894/article/details/83544399" target="_blank" rel="noopener">https://blog.csdn.net/qq\_43077894/article/details/83544399</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【js】判断字符串中是否包含某个字符串</title>
    <url>/2019/05/20/%E3%80%90js%E3%80%91%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="String对象方法"><a href="#String对象方法" class="headerlink" title="String对象方法"></a>String对象方法</h3><p>方法一: indexOf()   (推荐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"3"</span>) != <span class="number">-1</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。</p>
<p>方法二: search() </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">"3"</span>) != <span class="number">-1</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</p>
<p>方法三:match()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(str.match(reg))&#123;</span><br><span class="line">    <span class="comment">// 包含        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<h3 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h3><p>方法四:test() </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>test() 方法用于检索字符串中指定的值。返回 true 或 false。</p>
<p>方法五:exec()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(reg.exec(str))&#123;</span><br><span class="line">    <span class="comment">// 包含        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<p><a href="https://www.cnblogs.com/ooo0/p/7741651.html" target="_blank" rel="noopener">https://www.cnblogs.com/ooo0/p/7741651.html</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【vue】 vuecli3 打包</title>
    <url>/2019/07/20/%E3%80%90vue%E3%80%91%20vuecli3%20%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>vue-cli3 打包后 路径错误</p>
<p>1、新建 vue.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,    </span><br><span class="line">    lintOnSave:<span class="literal">false</span>     <span class="comment">//关闭eslint </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、router mode模式 设置为 hash</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【vue】代理方式跨域</title>
    <url>/2019/07/20/%E3%80%90vue%E3%80%91%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>前端使用代理主要用于跨域请求，</p>
<p>关于跨域：常用的方式</p>
<ul>
<li><p>JSONP：利用script标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数。</p>
</li>
<li><p>CORS：服务器设置HTTP响应头中Access-Control-Allow-Origin值，解除跨域限制    </p>
</li>
</ul>
<p>但是这两个跨域方案都存在一个致命的缺陷，严重依赖后端的协助，</p>
<p>代理 就可以作为 前端独立解决跨域的方案</p>
<p><strong>正向代理</strong></p>
<p>是指一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。</p>
<p> 　　vue-cli 3.x  新建vue.config.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123; <span class="comment">// proxy all requests starting with /api to jsonplaceholder</span></span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:8080'</span>,   <span class="comment">//代理接口</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">'/mock'</span>    <span class="comment">//代理的路径</span></span><br><span class="line"> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反向代理</strong></p>
<p>反向代理（Reverse Proxy）是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p><a href="https://www.cnblogs.com/softidea/p/7425894.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/7425894.html</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【vue】手动实现一个基础双向绑定</title>
    <url>/2019/04/20/%E3%80%90vue%E3%80%91%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">v-model</span>=<span class="string">'message'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind</span>=<span class="string">'message'</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="actionscript">        message:<span class="string">''</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'[v-model=message]'</span>)</span></span><br><span class="line"><span class="actionscript">    input.onkeyup=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        data.message = input.value</span><br><span class="line"><span class="actionscript">        <span class="comment">// data.message 发生改变 触发 Object.defineproperty</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">//Object.defineProperty 接受三个参数 </span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// obj 要在其上定义属性的对象。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// prop 要定义或修改的属性的名称。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// descriptor 将被定义或修改的属性描述符。 仅用到 get 和 set 属性　　 // 这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象。</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(data, <span class="string">'message'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// set 接受唯一参数，即该属性新的参数值。</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">set</span>(newValue)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">'[v-bind=message]'</span>)</span></span><br><span class="line"><span class="actionscript">            span.innerHTML=newValue　　　　　　　<span class="keyword">this</span>.value = newValue</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">// get 方法执行时没有参数传入</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">get</span>()&#123;　　　　     <span class="comment">//将newValue 返回给 message</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="keyword">this</span>.value</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【webpack】urlloader 图片路径问题</title>
    <url>/2019/04/10/%E3%80%90webpack%E3%80%91urlloader%20%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="webpack-url-loader-图片路径问题"><a href="#webpack-url-loader-图片路径问题" class="headerlink" title="webpack:url-loader 图片路径问题"></a>webpack:url-loader 图片路径问题</h3><p>我们使用webpack打包项目中，在处理图片路径时， 最常用的loader有两种， url-loader 和 file-loader。</p>
<p>我们在写项目中引用路径的时候，填写的URL是基于我们开发时的路径， 但是在webpack打包时， 会将各个模块打包成一个文件，里面引用的路径是相对于入口html文件，并不是相对于我们的原始文件路径的。loader 可以解析项目中引入的URL，并且根据配置，把图片拷贝到相应路径， 再将打包后的文件中的路径 替换为图像的最终路径。</p>
<p>file-loader 和 url-loader 都可以解决这个问题。 但是url-loader会将引入的图片进行编码， 我们引用的时候只需要引入这个文件就可以访问图片了， 可以大大减少 HTTP请求的次数。</p>
<p>url-loader 封装了 file-loader， 但并不依赖他， 所以我们可以只需要安装 url-loader就可以了。</p>
<p>在使用url-loader时，出现了 路径引用错误的 情况。</p>
<ol>
<li>问题复现</li>
</ol>
<p>webpack.prod.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'url-loader'</span>, <span class="comment">//是指定使用的loader和loader的配置参数</span></span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit:<span class="number">500</span>,  <span class="comment">//是把小于500B的文件打成Base64的格式，写入JS</span></span><br><span class="line">                    name: <span class="string">'images/[name]_[hash:7].[ext]'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(css)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.scss'</span>;</span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.png'</span>;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    Hello world</span><br><span class="line">        </span><br><span class="line">    ,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>index.css</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#root &#123;</span><br><span class="line">    color: aqua;</span><br><span class="line">    background: url(<span class="string">'./logo.png'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后的 css 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#root&#123;background:url(images&#x2F;logo_e179a47.png);color:#0ff&#125;</span><br></pre></td></tr></table></figure>

<p>打包后 的 文件结构</p>
<p>── css</p>
<p>│   └── app.9fd7e730df40df61cc5a.css</p>
<p>├── images</p>
<p>│   └── logo_e179a47.png</p>
<p>├── js</p>
<p>│  └── app.382da24eb9c30ee2.js</p>
<p>└── index.html</p>
<p>我们在浏览器中打开打包后的 index.html</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f420ecd33c50?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>可以看出我们在index.js 中 引入的图片是可以正常加载的， 但是我们在css中引入的背景图 并没有加载成功。</p>
<ol start="2">
<li>问题原因</li>
</ol>
<p>webpack 在 打包时， 首先会把图片 复制到 /dist/images/ 文件夹下， 然后把 css 文件中的url 路径 替换为webpack中options的name属性指向的路径，即 /images/logo.png, 但是这个路径是相对路径，是相对于 /dist/css/~.css 来说的， 所以此处引用的 文件地址为： /dist/css/images/logo.jpg。 但是我们打包后的css 文件夹中， 并没有 images/logo.png, 所以图片并没有渲染出来。 但是 对于 我们 index.js 中 引用的图片， 此处相对路径是相对于 index.html 来说的， 所以 是可以取到图片的。</p>
<ol start="3">
<li>解决方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: <span class="regexp">/\.(css)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">                publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在为css文件配置 loader时， 添加 publicPath 属性。 这样做， 我们在图片打包时， 仍会将图片复制在 /dist/images/ 文件夹之下， 但是 在css文件中引用时， 会将路径替换为 publicPath + name。</p>
<p>打包后的 css 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#root&#123;background:url(..&#x2F;images&#x2F;logo_e179a47.png);color:#0ff&#125;</span><br></pre></td></tr></table></figure>

<p>至此， 项目中 css 的文件引用路径 和 js 中的文件引用路径 均为正确的图片路径。</p>
<p><a href="https://juejin.im/post/5b8d1e926fb9a019b66e4657" target="_blank" rel="noopener">https://juejin.im/post/5b8d1e926fb9a019b66e4657</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【webpack】webpack基本配置</title>
    <url>/2019/04/10/%E3%80%90webpack%E3%80%91webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin \= <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>); <span class="comment">//配置路径</span></span><br><span class="line"><span class="keyword">const</span> PATH = &#123; <span class="comment">//path.jion 把当前文件的绝对路径与相对路径相结合生成新的路径</span></span><br><span class="line">    app:path.join(\_\_dirname,<span class="string">"src/index.js"</span>),</span><br><span class="line">    build:path.join(\_\_dirname,<span class="string">"dist"</span>)</span><br><span class="line">&#125; <span class="comment">//module 打包的配置项</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        app:PATH.app</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">"\[name\].js"</span>,</span><br><span class="line">        path:PATH.build</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="built_in">module</span>:&#123; <span class="comment">//test  匹配类型 通过loader进行合并</span></span><br><span class="line"> rules:\[</span><br><span class="line">           &#123;</span><br><span class="line">                test:<span class="regexp">/\\.(js|jsx)$/</span>,</span><br><span class="line">                use:&#123; <span class="comment">//打包js  一个打包的工具</span></span><br><span class="line">                    loader:<span class="string">"babel-loader"</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        presets:\[<span class="string">"@babel/env"</span>,<span class="string">"@babel/react"</span>\]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">               exclude:\_\_dirname+<span class="string">"node\_modules"</span> &#125;,&#123;</span><br><span class="line">               test:<span class="regexp">/\\.(css|scss)$/</span>,</span><br><span class="line">               loader:\[<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>,<span class="string">"sass-loader"</span>\]</span><br><span class="line">           &#125;</span><br><span class="line">       \]</span><br><span class="line">   &#125;, <span class="comment">//plugins  插件</span></span><br><span class="line"> plugins:\[ <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:<span class="string">"index.html"</span>,</span><br><span class="line">            filename:<span class="string">"index.html"</span> &#125;)</span><br><span class="line">   \]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔webhooks实现hexo自动部署</title>
    <url>/2019/05/10/%E5%AE%9D%E5%A1%94hexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="webhook自动部署"><a href="#webhook自动部署" class="headerlink" title="webhook自动部署"></a>webhook自动部署</h3><p>首先确保你的服务器已经安装了宝塔，安装webhook插件 ，添加hook 输入名称及一下脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line"><span class="comment"># 输出当前时间</span></span><br><span class="line">date --date=<span class="string">'0 days ago'</span> <span class="string">"+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Start"</span></span><br><span class="line"><span class="comment"># 判断宝塔WebHook参数是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$1</span>"</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"param参数错误"</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"End"</span></span><br><span class="line">          <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># git项目路径</span></span><br><span class="line">gitPath=<span class="string">"/www/wwwroot/<span class="variable">$1</span>"</span></span><br><span class="line"><span class="comment"># git 网址</span></span><br><span class="line">gitHttp=<span class="string">"http://git.xxxxx.com/<span class="variable">$1</span>.git"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Web站点路径：<span class="variable">$gitPath</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断项目路径是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$gitPath</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$gitPath</span></span><br><span class="line">        <span class="comment"># 判断是否存在git目录</span></span><br><span class="line">        <span class="keyword">if</span> [ ! -d <span class="string">".git"</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"在该目录下克隆 git"</span></span><br><span class="line">                git <span class="built_in">clone</span> <span class="variable">$gitHttp</span> gittemp</span><br><span class="line">                mv gittemp/.git .</span><br><span class="line">                rm -rf gittemp</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="comment"># 拉取最新的项目文件</span></span><br><span class="line">        git reset --hard origin/master</span><br><span class="line">        git pull</span><br><span class="line">        <span class="comment"># 设置目录权限</span></span><br><span class="line">        chown -R www:www <span class="variable">$gitPath</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"End"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"该项目路径不存在"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"End"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>然后会生成 一个密钥 和 相关的链接</p>
<h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><p><img src="http://cloud.asenper.cn//20200613184752.png" alt="image-20200613184750432"></p>
<p>如图,添加webhooks,Payload URL为上一步生成的链接，Secret为密钥<br>就这么简单</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>内蒙古之旅</title>
    <url>/2019/07/14/%E5%86%85%E8%92%99%E5%8F%A4%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h5 id="去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）"><a href="#去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）" class="headerlink" title="去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）"></a>去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）</h5><p><img src="http://cloud.asenper.cn//20200613191858.jpg" alt="仙沙岛"><br><img src="http://cloud.asenper.cn//20200613195203.jpg" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://cloud.asenper.cn//20200613195241.jpg" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://cloud.asenper.cn//20200613195316.jpg" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_120831.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_122822.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_123545.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_131239.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_131239.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://cloud.asenper.cn//20200613192909.jpg" alt="杂技表演"><br><img src="http://cloud.asenper.cn//20200613192717.jpg" alt="杂技表演"><br><img src="http://common.msmk.tech/IMG_20190713_184312.jpg?imageslim" alt="呼和浩特成吉思汗公园"><br><img src="http://common.msmk.tech/IMG_20190713_184902.jpg?imageslim" alt="呼和浩特成吉思汗公园"><br><img src="http://cloud.asenper.cn//20200613194650.jpg" alt="呼和浩特跑马场"><br><img src="http://common.msmk.tech/IMG_20190713_194229.jpg?imageslim" alt="呼和浩特跑马场"></p>
]]></content>
  </entry>
  <entry>
    <title>微信小程序点击多次navigator跳转无反应</title>
    <url>/2020/05/27/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%82%B9%E5%87%BB%E5%A4%9A%E6%AC%A1navigator%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%8F%8D%E5%BA%94/</url>
    <content><![CDATA[<p><code>navigator</code>组件<code>open-type</code>属性默认值为<code>navigate</code></p>
<p>而<code>navigate</code>对应<code>navigateTo</code>方法，可以看到文档中对<code>navigateTo</code>的说明：</p>
<p>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈<strong>最多十层</strong>。</p>
<p><strong>将 <code>open-type</code>属性值设为<code>redirect</code>即可</strong></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/2019/06/01/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>所谓正向代理就是顺着请求的方向进行的代理，即代理服务器他是由你配置为你服务，去请求目标服务器地址。</p>
<p>比如我们要去访问谷歌网站，我们直接访问不通，那么我们就可以找一个代理服务器为我们服务，我们通过代理服务器请求到谷歌网站。对于谷歌而言他只知道有一个服务器访问了自己，并不知道这件事你是访问不了他,找了一个代理服务器访问自己。</p>
<p>在举一个通俗的例子。你需要钱，C正好有钱，但是你C不直接借给你。你和B关系比较好，B可以找C借到钱。你和B沟通后，由B来找C借到钱后在给你。<br>上面的两个例子中的共同特点是 代理服务器和B都是你找到的，为你而服务的，代表你的利益。我们还可以让代理服务器给你代理到推特、Facebook等，他是代理的你。<br><img src="https://img-blog.csdnimg.cn/20190531180703829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhlbmdodWk1MjAx,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>所谓反向代理正好与正向代理相反，代理服务器是为目标服务器服务的，虽然整体的请求返回路线都是一样的都是Client到Proxy到Server。</p>
<p>比如 我们访问百度网站，百度的代理服务器对外的域名为 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 。具体内部的服务器节点我们不知道。现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回。</p>
<p>再举例：我们同样需要钱，但是我们又不知道谁有钱，所以我们找了一家网贷平台，你提交资料后，网贷平台直接将钱打给你。但是你不知道，也不用关注网贷平台的钱从哪里来。网贷平台内部他们可能从哪一个财主哪里融的钱。对你而言网贷平台和他们的金主是一起的。</p>
<p>同样通过上面我们例子可以看到，此时的代理服务器和后面的目标主机是一个系统的（百度公司、网贷平台）。他们是对外提供服务的，所以称为反向代理，代理的是后的人。<br><img src="https://img-blog.csdnimg.cn/20190531180723798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhlbmdodWk1MjAx,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p><strong>正向代理代理的对象是客户端，反向代理代理的对象是服务端</strong></p>
<p>原文链接：<a href="https://blog.csdn.net/liuhenghui5201/article/details/90720442" target="_blank" rel="noopener">https://blog.csdn.net/liuhenghui5201/article/details/90720442</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Git报错:error: You have not concluded your merge (MERGE_HEAD exists)</title>
    <url>/2019/05/18/%E8%A7%A3%E5%86%B3Git%E6%8A%A5%E9%94%99-error-You-have-not-concluded-your-merge-MERGE-HEAD-exists/</url>
    <content><![CDATA[<p>Git fetch和git pull的区别:</p>
<a id="more"></a>
<p>都可以从远程获取最新版本到本地<br>1.Git fetch:只是从远程获取最新版本到本地,不会merge(合并)<br>$:git fetch origin master   //从远程的origin的master主分支上获取最新版本到origin/master分支上<br>$:git log -p master..origin/master //比较本地的master分支和origin/master分支的区别<br>$:git merge origin/master          //合并</p>
<p>2.Git pull:从远程获取最新版本并merge(合并)到本地<br>$:git pull origin master  //相当于进行了 git fetch 和 git merge两部操作<br>1<br>实际工作中,可能git fetch更好一些, 因为在merge前,可以根据实际情况决定是否merge<br>再说导致报错:error: You have not concluded your merge (MERGE_HEAD exists).的原因可能是在以前pull下来的代码自动合并失败<br>解决办法一:保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取<br>$:git merge –abort<br>$:git reset –merge<br>$:git pull</p>
<p>解决办法二:舍弃本地代码,远端版本覆盖本地版本(慎重)<br>$:git fetch –all<br>$:git reset –hard origin/master<br>$:git fetch</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>解决cannot remove &#39;.user.ini&#39;Operation not permitted</title>
    <url>/2019/04/18/%E8%A7%A3%E5%86%B3cannot-remove-user-ini-Operation-not-permitted/</url>
    <content><![CDATA[<p>在Linux中删除整个git仓库，删除失败出现 cannot remove ‘.user.ini’Operation not permitted，原因就是文件中含有某种属性不可更改，删除该属性就可以了</p>
<a id="more"></a>
<p>在Linux中rm -rf的威力是十分巨大的，特别是附带了 -f 参数，不少新手都干过用root用户执行 rm -rf /命令这种傻事，如果云服务器没有快照，简直就是灾难，从根目录开始所有文件被递归删除，连系统都被损坏。</p>
<p>但是，偶尔也会遇到使用rm -rf也删除不了的文件，执行后报rm: cannot remove `.user.ini’: Operation not permitted，</p>
<p>这时候需要使用到Linux的chattr命令， chattr命令用于改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：<br>a：让文件或目录仅供附加用途。<br>b：不更新文件或目录的最后存取时间。<br>c：将文件或目录压缩后存放。<br>d：将文件或目录排除在倾倒操作之外。<br>i：不得任意更动文件或目录。<br>s：保密性删除文件或目录。<br>S：即时更新文件或目录。<br>u：预防以外删除。<br>语法chattr[-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录…]参数<br>　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。<br>　　-v&lt;版本编号&gt; 设置文件或目录版本。<br>　　-V 显示指令执行过程。<br>　　+&lt;属性&gt; 开启文件或目录的该项属性。<br>　　-&lt;属性&gt; 关闭文件或目录的该项属性。<br>　　=&lt;属性&gt; 指定文件或目录的该项属性。</p>
<p>进入到<code>.user.ini&#39;所在目录，执行一下 lsattr -a，查看文件下下边包含文件的属性，看到</code>.user.ini’有个’i’属性，代表不得任意更动文件或目录，正是此属性在作祟：</p>
<p>然后执行命令：<br><code>chattr -i .user.ini</code><br>就可以去除掉此属性，然后我们再执行删除，就可以顺利删除掉了：</p>
<p>原文链接：<a href="https://blog.csdn.net/sinat_35861727/article/details/79040755" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35861727/article/details/79040755</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
