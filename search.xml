<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS中的prototype、__proto__与constructor</title>
    <url>/2019/09/08/JS%E4%B8%AD%E7%9A%84prototype%E3%80%81-proto-%E4%B8%8Econstructor/</url>
    <content><![CDATA[<p>​    原文链接 <a href="https://blog.csdn.net/cc18868876837/article/details/81211729" target="_blank" rel="noopener">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>作为一名前端工程师，必须搞懂JS中的prototype、_ _ proto_ _ 与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，_ _ proto_ _ 属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格：_ <em>proto</em> <em>，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为</em> _ proto_ _ ，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({_ _ proto_ _ : null}) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。<br>     现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示：<br>看到这图别怕，让我们一步步剖析，彻底搞懂它们！</p>
<p><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(6).png" alt=""></p>
<p>  图的说明：右下角为图例，红色箭头表示_ _ proto_ _ 属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。</p>
<h3 id="2-proto-属性"><a href="#2-proto-属性" class="headerlink" title="2. _ _ proto _ _ 属性  "></a>2. _ _ proto _ _ 属性  </h3><p>  首先，我们需要牢记两点：①_ _ proto_ _ 和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有_ _ proto_ _ 和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析：</p>
<p><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(5).png" alt=""></p>
<p>  第一，这里我们仅留下 _ <em>proto</em> _ 属性，它是对象所独有的，可以看到_ _ proto_ _ 属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的_ _ proto_ _ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的_ _ proto_ _ 属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过_ _ proto_ _ 属性来连接对象直到null的一条链即为我们所谓的原型链。<br>  其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠_ _ proto_ _ 继承而来的。</p>
<h3 id="3-prototype属性"><a href="#3-prototype属性" class="headerlink" title="3. prototype属性"></a>3. prototype属性</h3><p>  第二，接下来我们看 prototype 属性：</p>
<p>  <img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(4).png" alt=""></p>
<p>prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：f1._ _ proto_ _  === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>
<h3 id="4-constructor属性"><a href="#4-constructor属性" class="headerlink" title="4. constructor属性"></a>4. constructor属性</h3><p>最后，我们来看一下 constructor 属性：<br>    <img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(3).png" alt=""><br>    constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合_ _ proto_ _ 属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。<br><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(2).png" alt=""></p>
<p>  感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过_ _ proto_ _ 在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象._ _ proto_ _  === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过_ _ proto_ _ 找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下：<br><img src="https://raw.githubusercontent.com/asenper/images/master/js/1%20(1).png" alt=""></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>我们需要牢记两点：①_ _ proto_ _ 和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有_ _ proto_ _ 和constructor属性。<br>_ _ proto_ _ 属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的_ _ proto_ _ 属性所指向的那个对象（父对象）里找，一直找，直到_ _ proto_ _ 属性的终点null，再往上找就相当于在null上取值，会报错。通过_ _ proto_ _ 属性将对象连接起来的这条链路即我们所谓的原型链。<br>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1._ _ proto_ _  === Foo.prototype。<br>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(Person);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器中配置Nginx一个域名访问多个项目</title>
    <url>/2019/04/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E9%85%8D%E7%BD%AENginx%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>服务器配置个人博客和其它项目使其能够根据不同 url 跳转到不同项目，(例如:<em>localhosh://A 项目/，localhosh://B 项目/</em> )因为对服务器和 Nginx 部署了解甚少，在此记录一下</p>
<a id="more"></a>

<h2 id="location-模块的匹配介绍"><a href="#location-模块的匹配介绍" class="headerlink" title="location 模块的匹配介绍"></a>location 模块的匹配介绍</h2><blockquote>
<ol>
<li>”=”前缀指令匹配，如果匹配成功，则停止其他匹配。</li>
<li>普通字符串指令匹配，顺序是从长到短，匹配成功的 location 如果使用^~，则停止其他匹配（正则匹配）。</li>
<li>正则表达式指令匹配，按照配置文件里的顺序，成功就停止其他匹配。</li>
<li>如果第三步中有匹配成功，则使用该结果，否则使用第二步结果。</li>
</ol>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote>
<ol>
<li>匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的 location 顺序是无关紧要的，反正最后 nginx 会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个匹配的正则表达式将停止搜索。</li>
<li>一般情况下，匹配成功了普通字符串 location 后还会进行正则表达式 location 匹配。有两种方法改变这种行为，其一就是使用“=”前缀，这时执行的是严格匹配，并且匹配成功后立即停止其他匹配，同时处理这个请求；另外一种就是使用“^~”前缀，如果把这个前缀用于一个常规字符串那么告诉 nginx 如果路径匹配那么不测试正则表达式。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location = <span class="string">``</span> / uri;</span><br></pre></td></tr></table></figure>

<p>=开头表示精确匹配，只有完全匹配上才能生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ^ (~<span class="string">``</span> / uri);</span><br></pre></td></tr></table></figure>

<p>^~ 开头对 URL 路径进行前缀匹配，并且在正则之前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~ pattern</span><br></pre></td></tr></table></figure>

<p>~开头表示区分大小写的正则匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~* pattern</span><br></pre></td></tr></table></figure>

<p>~*开头表示不区分大小写的正则匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location<span class="string">``</span> / uri;</span><br></pre></td></tr></table></figure>

<p>不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location /</span><br></pre></td></tr></table></figure>

<p>通用匹配，任何未匹配到其它 location 的请求都会匹配到，相当于 switch 中的 default。</p>
<h2 id="alias-和-root-的区别"><a href="#alias-和-root-的区别" class="headerlink" title="alias 和 root 的区别"></a>alias 和 root 的区别</h2><p>在<a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">VUE</a>中也有alias的概念，感觉两者差不多</p>
<ul>
<li>alias 和 root 都是用来指定文件路径的，root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</li>
<li>root的处理结果是：root路径＋location路径</li>
<li>alias的处理结果是：使用alias路径替换location路径</li>
<li>alias是一个目录别名的定义，root则是最上层目录的定义。</li>
<li>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件</li>
<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>
<li>alias只能位于location块中。（root可以不放在location中）</li>
</ul>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> *****</span><br><span class="line"> *****</span><br><span class="line"> # 域名+项目1名称</span><br><span class="line"> location ^~ <span class="regexp">/A/</span> &#123;</span><br><span class="line">   alias /data/A/;</span><br><span class="line"> &#125;</span><br><span class="line"> # 域名+项目2名称</span><br><span class="line"> location ^~ <span class="regexp">/B/</span> &#123;</span><br><span class="line">   alias /data/B/;</span><br><span class="line"> &#125;</span><br><span class="line">    ****</span><br><span class="line">    ****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.nginx.cn/4658.html" target="_blank" rel="noopener">nginx的location、root、alias指令用法和区别</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Node项目部署</title>
    <url>/2019/05/12/Node%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="利用宝塔可以很快的搭建你需要的环境"><a href="#利用宝塔可以很快的搭建你需要的环境" class="headerlink" title="利用宝塔可以很快的搭建你需要的环境"></a>利用宝塔可以很快的搭建你需要的环境</h2><p>安装 ：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html" target="_blank" rel="noopener">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>将你的项目上传到指定的目录</p>
<h2 id="添加网站"><a href="#添加网站" class="headerlink" title="添加网站"></a>添加网站</h2><p><img src="https://img2020.cnblogs.com/blog/1524685/202006/1524685-20200601100634195-561242539.png" alt=""></p>
<h2 id="安装pm2管理器，方便管理你的Node项目和版本"><a href="#安装pm2管理器，方便管理你的Node项目和版本" class="headerlink" title="安装pm2管理器，方便管理你的Node项目和版本"></a>安装pm2管理器，方便管理你的Node项目和版本</h2><p>PM2是Node.js应用程序的生产流程管理器，内置负载均衡。它可以帮助您保持Node应用程序永久活动，重起这些node应用程序也不需要停机，并简化常见的系统管理任务。<br>填写项目跟目录和启动文件,启动你的node服务，也可以自己安装<code>forever</code><br><img src="https://img2020.cnblogs.com/blog/1524685/202006/1524685-20200601100016539-687074251.png" alt=""></p>
<h2 id="设置nginx反向代理"><a href="#设置nginx反向代理" class="headerlink" title="设置nginx反向代理"></a>设置nginx反向代理</h2><p>执行完以上步骤，你会发现并不能正常访问该项目，这时需要用到<strong><a href="/2019/06/01/正向代理和反向代理/">nginx的反向代理</a></strong><br>打开 网站——&gt;设置——&gt;配置文件<br>在 <code>server</code>中添加一个配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意格式，在宝塔中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;&#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样配置会报错</p>
<h3 id="配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加"><a href="#配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加" class="headerlink" title="配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加"></a>配置完成后就可以用你配置的网站名访问了，如果有配置端口号，别忘了加</h3>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>a标签target=‘_blank’的安全问题</title>
    <url>/2020/06/12/a%E6%A0%87%E7%AD%BEtarget-%E2%80%98-blank%E2%80%99%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>外链用了 target=”_blank” 结果悲剧了​​​​<br>我们知道，网页里的a标签默认在当前窗口跳转链接地址，如果需要在新窗口打开，需要给 a 标签添加一个target=”_blank”属性。​<br>顺便提下一个有意思的现象，很早之前我就发现，国外网站倾向于在当前页跳转，而国内网站喜欢打开新窗口。不信你们可以去验证下。我不知道这是交互设计上的文化差异，还 是技术上的开发习惯。​<br> 当然，这两种方式各有优缺点。当前页跳转显得操作比较有连贯性，不会贸然打断用户的注意力，也会减少浏览器的窗口（tab 页）数量。但是对于需要反复回到初始页面的场景 来说，就很麻烦了。比如搜索结果页面，通常需要查看对比几个目标地址，保留在多个窗口还是比较方便。​<br> 今天要说的不只是用户体验上的差别，而是涉及安全和性能。​</p>
</blockquote>
<h2 id="安全隐患​"><a href="#安全隐患​" class="headerlink" title="安全隐患​"></a>安全隐患​</h2><p>如果只是加上target=”_blank”，打开新窗口后，新页面能通过window.opener获取到来源页面的window对象，即使跨域也一样。虽然跨域的页面对于这个对象的属性访问有所限制，但还是有漏网之鱼。<br>比如修改window.opener.location的值，指向另外一个地址。你想想看，刚刚还是在某个网站浏览，随后打开了新窗口，结果这个新窗口神不知鬼不觉地把原来的网页地址改了。这个可以用来做什么？钓鱼啊！等你回到那个钓鱼页面，已经伪装成登录页，你可能就稀里糊涂把账号密码输进去了。<br>还有一种玩法，如果你处于登录状态，有些操作可能只是发送一个GET请求就完事了。通过修改地址，就执行了非你本意的操作，其实就是 CSRF 攻击。​</p>
<h2 id="性能问题​"><a href="#性能问题​" class="headerlink" title="性能问题​"></a>性能问题​</h2><p>除了安全隐患外，还有可能造成性能问题。通过target=”_blank”打开的新窗口，跟原来的页面窗口共用一个进程。如果这个新页面执行了一大堆性能不好的 JavaScript 代码，占用了大量系统资源，那你原来的页面也会受到池鱼之殃。​</p>
<h2 id="解决方案​"><a href="#解决方案​" class="headerlink" title="解决方案​"></a>解决方案​</h2><p>尽量不使用target=”_blank”，如果一定要用，需要加上rel=”noopener”或者rel=”noreferrer”。<strong>但是，火狐并不支持这个属性值，火狐浏览器里需要写成rel=”noreferrer”，所以我们可以将两个属性值合并写成rel=”noopener noreferrer”来完整覆盖。</strong>这样新窗口的window.openner就是null了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。​<br>另外，对于通过window.open的方式打开的新页面，可以这样做：​</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yourWindow = <span class="built_in">window</span>.open();</span><br><span class="line">yourWindow.opener = <span class="literal">null</span>;</span><br><span class="line">yourWindow.location = <span class="string">"icon网页链接"</span>;</span><br><span class="line">yourWindow.target = <span class="string">"_blank"</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>js易错题</title>
    <url>/2019/04/10/js%E6%98%93%E9%94%99%E9%A2%98/</url>
    <content><![CDATA[<h2 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h2><ul>
<li>箭头函数不能作构造函数。</li>
<li>箭头函数没有argument参数。如果你想访问箭头函数的直接参数，可以使用剩余参数 …args，剩余参数 … args 接受箭头函数的执行参数</li>
<li>箭头函数没有自己的This.指向，箭头函数内部的 this 值始终等于外部函数的 this值。换句话说，箭头函数可按词法解析 this，箭头函数没有定义自己的执行上下文。</li>
<li>常规函数如果缺少 return 语句，或者 return 语句后面没有表达式，则常规函数隐式返回undefined<br>如果箭头函数包含一个表达式，而你省略了该函数的花括号，则将显式返回该表达式。这些是内联箭头函数<h2 id="This指向问题"><a href="#This指向问题" class="headerlink" title="This指向问题"></a>This指向问题</h2></li>
<li>this是声明函数时附加的参数，指向特定的对象，也就是隐藏参数。</li>
<li>this提供了一种更加优雅的方式来隐式的传递对象引用。</li>
<li>this永远指向调用他的对象<h4 id="一个测试题"><a href="#一个测试题" class="headerlink" title="一个测试题"></a>一个测试题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">5</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">obj.method(fn, <span class="number">1</span>);<span class="comment">//输出是什么？</span></span><br></pre></td></tr></table></figure>
只要认准 <strong>this永远指向调用他的对象</strong>，这道题就很简单了<br>在执行 <code>obj.method()</code>时，如果函数内部执行<code>console.log(this.length)</code>，函数的调用对象为<code>obj</code>,<code>this</code>指向<code>obj</code>，但是<code>method()</code>内部执行的是<code>fn()</code>函数，而<code>fn()</code>函数的调用对象为<code>window</code>，即<code>window.fn()</code>，即<code>this</code>指向<code>window</code>，输出为 10；<br>参数<code>fn</code>和<code>1</code>属于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">arguments</a>类数组对象，<code>arguments[0]()</code>就是调用了<code>fn()</code>,此时<code>fn</code>的作用域为<code>arguments</code>，即<code>this</code>指向<code>arguments</code>，<code>this.length</code>即传入的参数的长度2<br>结果输出为 10，2</li>
</ul>
<h3 id="闭包和自执行参数"><a href="#闭包和自执行参数" class="headerlink" title="闭包和自执行参数"></a>闭包和自执行参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">test(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;  <span class="comment">// this指向window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getA = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>)   <span class="comment">//自执行函数 返回1，b没有用到</span></span><br><span class="line">即:  </span><br><span class="line">test(getA)(<span class="number">4</span>)  <span class="comment">// test(1)(4)</span></span><br><span class="line">test(<span class="number">1</span>) 返回函数</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a+b</span><br><span class="line">&#125;</span><br><span class="line">此时 a 为 <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">很明显 最后返回 <span class="number">1</span>+<span class="number">4</span> 结果为 <span class="number">5</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2019/04/12/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>

<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"> </span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"> </span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"> </span><br><span class="line">注意：</span><br><span class="line">1.第二行分割表头和内容“-”有一个就行，为了对齐，多加了几个</span><br><span class="line">2.文字默认居左，“-”两边加：表示文字居中；“-”右边加：表示文字居右</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​   &#96;&#96;&#96; 语言类型 如 js &#x2F; html &#x2F; php</span><br><span class="line">    代码...</span><br><span class="line">    代码...</span><br><span class="line">    代码...</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>```</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器登录显示version N/A -&gt; N/A is not yet installed</title>
    <url>/2020/06/09/nvm%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>服务器登录显示 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.</span><br><span class="line">You need to run &quot;nvm install N&#x2F;A&quot; to install it before using it</span><br></pre></td></tr></table></figure>
<p>虽然没有影响使用，但看着真的很别扭，强迫证表示一定要干掉它！<br>问题原因看描述就很清楚了，nvm使用了没有安装的node版本，<br>nvm list 查看下node版本列表<br>nvm -v 查看下当前node版本号<br>nvm use 当前node版本号<br>这样就可以了<br>还有一种方法<br>之前服务器安装了宝塔，在宝塔里安装了pm2来管理node,但是在此之前我记得是单独装过node，问题应该是出在这里了😀</p>
]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>JS继承的实现方式</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91JS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>原文链接 <a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">https://www.cnblogs.com/humin/p/4556820.html</a></p>
<p>既然要实现继承，那么首先我们得有一个父类，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p><strong>核心：</strong> 将父类的实例作为子类的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">'cat'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ol>
<p>缺点：</p>
<ol>
<li>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）（详细请看附录代码： 示例1）</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<p>推荐指数：★★（3、4两大致命缺陷）</p>
<p><strong>2017-8-17 10:21:43补充：感谢 <a href="http://home.cnblogs.com/u/1066372/" target="_blank" rel="noopener">MMHS</a> 指出。缺点1中描述有误：可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在<code>new Animal()</code>这样的语句之后执行。</strong></p>
<p><strong>2018-9-10 00:03:45补充：感谢 <a href="https://www.cnblogs.com/lianghaijie-ctw/" target="_blank" rel="noopener">IRVING_J</a> 指出。缺点3中的描述不够充分。更正为：来自原型对象的所有属性被所有实例共享。</strong></p>
<h3 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h3><p><strong>核心：</strong>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>解决了1中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ol>
<p>推荐指数：★★（缺点3）</p>
<h3 id="3、实例继承"><a href="#3、实例继承" class="headerlink" title="3、实例继承"></a>3、实例继承</h3><p><strong>核心：</strong>为父类实例添加新特性，作为子类实例返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal();</span><br><span class="line">  instance.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>,返回的对象具有相同的效果</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ol>
<p>推荐指数：★★</p>
<h3 id="4、拷贝继承"><a href="#4、拷贝继承" class="headerlink" title="4、拷贝继承"></a>4、拷贝继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> animal)&#123;</span><br><span class="line">    Cat.prototype[p] = animal[p];</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>支持多继承</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ol>
<p>推荐指数：★（缺点1）</p>
<h3 id="5、组合继承"><a href="#5、组合继承" class="headerlink" title="5、组合继承"></a>5、组合继承</h3><p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">// 感谢 @学无止境c 的提醒，组合继承也是需要修复构造函数指向的。Cat.prototype.constructor = Cat;</span></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ol>
<p>缺点：</p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<p>推荐指数：★★★★（仅仅多消耗了一点内存）</p>
<h3 id="6、寄生组合继承"><a href="#6、寄生组合继承" class="headerlink" title="6、寄生组合继承"></a>6、寄生组合继承</h3><p><strong>核心：</strong>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line">  <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  Super.prototype = Animal.prototype;</span><br><span class="line">  <span class="comment">//将实例作为子类的原型</span></span><br><span class="line">  Cat.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true感谢 @bluedrink 提醒，该实现没有修复constructor。Cat.prototype.constructor = Cat; // 需要修复下构造函数</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>堪称完美</li>
</ol>
<p>缺点：</p>
<ol>
<li>实现较为复杂</li>
</ol>
<p>推荐指数：★★★★（实现复杂，扣掉一颗星）</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>for、foreach终止循环</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91for%E3%80%81foreach%E7%BB%88%E6%AD%A2%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>foreach 通过 throw   ***  抛出错误  通过 try {}catch(e){}接受错误 根据错误做出判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      list.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(!i.title)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="string">'BreakT'</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.option_type == <span class="number">0</span> || i.option_type == <span class="number">1</span>) &#123;</span><br><span class="line">                i.option.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (!v &amp;&amp; v !== <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="keyword">throw</span> <span class="string">'BreakV'</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                 &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">     uni.showToast(&#123;</span><br><span class="line">          icon: <span class="string">'none'</span>,</span><br><span class="line">          title: e == <span class="string">'BreakT'</span> ? <span class="string">'您有题目未添加标题，请检查'</span> :<span class="string">'您有选项未设置问题，请检查'</span></span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>for循环直接 break</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js去除字符串空格</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91js%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p><strong>( 1 ) replace正则匹配方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">　　去除字符串内所有的空格：str = str.replace(<span class="regexp">/\\s\*/g</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">　　去除字符串内两头的空格：str = str.replace(<span class="regexp">/^\\s\*|\\s\*$/g</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">　　去除字符串内左侧的空格：str = str.replace(<span class="regexp">/^\\s\*/</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">　　去除字符串内右侧的空格：str = str.replace(<span class="regexp">/(\\s\*$)/g</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>　　<strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/\\s\*/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/^\\s\*|\\s\*$/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/^\\s\*/</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6 //输出右侧有空格左侧无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.replace(<span class="regexp">/(\\s\*$)/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">// 6 6//输出左侧有空格右侧无空格</span></span><br></pre></td></tr></table></figure>
<p><strong>( 2 ) str.trim()方法</strong></p>
<p>　　trim()方法是用来删除字符串两端的空白字符并返回，trim方法并不影响原来的字符串本身，它返回的是一个新的字符串。</p>
<p>　　缺陷：只能去除字符串两端的空格，不能去除中间的空格</p>
<p>　　<strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = str.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line">　　单独去除左侧空格则使用 str.trimLeft(); <span class="comment">//var str\_1 = str.trimLeft();</span></span><br><span class="line"></span><br><span class="line">　　单独去除右侧空格则使用 str.trimRight();<span class="comment">//var str\_1 = str.trimRight();</span></span><br></pre></td></tr></table></figure>
<p><strong>( 3 ) JQ方法：$.trim(str)方法</strong></p>
<p>　　$.trim() 函数用于去除字符串两端的空白字符。</p>
<p>　　<strong>注意：</strong>$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。</p>
<p>　　<strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str\_1 = $.trim(str);</span><br><span class="line"><span class="built_in">console</span>.log(str\_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br></pre></td></tr></table></figure>
<p>转<a href="https://www.cnblogs.com/a-cat/p/8872498.html" target="_blank" rel="noopener">https://www.cnblogs.com/a-cat/p/8872498.html</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】promise</title>
    <url>/2019/04/20/%E3%80%90JS%E3%80%91promise/</url>
    <content><![CDATA[<h3 id="八段代码彻底掌握-Promise"><a href="#八段代码彻底掌握-Promise" class="headerlink" title="八段代码彻底掌握 Promise"></a>八段代码彻底掌握 Promise</h3><h3 id="原文链接-https-juejin-im-post-597724c26fb9a06bb75260e8"><a href="#原文链接-https-juejin-im-post-597724c26fb9a06bb75260e8" class="headerlink" title="原文链接  https://juejin.im/post/597724c26fb9a06bb75260e8"></a>原文链接  <a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">https://juejin.im/post/597724c26fb9a06bb75260e8</a></h3><h3 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"create a promise"</span></span><br><span class="line"><span class="string">"after new Promise"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure>

<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>
<h3 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);  </span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    reject(<span class="number">3</span>);  </span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p3);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"rejected"</span>, [[PromiseValue]]: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个<code>setTimeout</code>函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h3 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  reject(<span class="string">"reject"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"success1"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure>

<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为<code>success2</code>，p2中<code>reject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>
<h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="string">"resolve"</span></span><br><span class="line"><span class="string">"reject: reject"</span></span><br></pre></td></tr></table></figure>

<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><code>return</code> 一个同步的值 ，或者 <code>undefined</code>（当没有返回一个有效值时，默认返回undefined），<code>then</code>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><code>return</code> 另一个 Promise，<code>then</code>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
<li><code>throw</code> 一个同步异常，<code>then</code>方法将返回一个rejected状态的Promise, 值是该异常。</li>
</ul>
<p>根据以上分析，代码中第一个<code>then</code>会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个<code>then</code>输出的值是2。第二个<code>then</code>中没有返回值，因此将返回默认的undefined，于是在第三个<code>then</code>中输出undefined。第三个<code>then</code>和第四个<code>then</code>中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个<code>then</code>中成功的回调函数和第五个<code>then</code>中失败的回调函数处理。</p>
<h3 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;which one is called first ?&#39;</span><br><span class="line">&#39;success&#39;</span><br></pre></td></tr></table></figure>

<p>Promise接收的函数参数是同步执行的，但<code>then</code>方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h3 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve( <span class="number">1</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve( <span class="number">2</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</span><br><span class="line">    foo.bar();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1 then err: <span class="built_in">ReferenceError</span>: foo is not defined</span><br><span class="line">p2 then value: <span class="number">2</span></span><br><span class="line">p1 then then value: <span class="literal">undefined</span></span><br><span class="line">p2 then then err: <span class="built_in">ReferenceError</span>: foo is not defined</span><br><span class="line">p2 then then then value: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Promise中的异常由<code>then</code>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<code>then</code>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<code>then</code>的回调函数是交替执行的 ，这正是由Promise <code>then</code>回调的异步性决定的。</p>
<h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">p2=<span class="number">1</span></span><br><span class="line">p1=<span class="number">1</span></span><br><span class="line">p4=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<code>then</code>最先调用，但在控制台上是最后输出结果的呢？因为p4的<code>resolve</code>中接收的参数是一个Promise对象p1，<code>resolve</code>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h3 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p3 rejected: [object <span class="built_in">Promise</span>]</span><br><span class="line">p1 fulfilled: resolve</span><br><span class="line">p2 rejected: reject</span><br></pre></td></tr></table></figure>

<p>Promise回调函数中的第一个参数<code>resolve</code>，会对Promise执行”拆箱”动作。即当<code>resolve</code>的参数是一个Promise对象时，<code>resolve</code>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此<code>fulfilled</code>回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此<code>rejected</code>回调被执行。但Promise回调函数中的第二个参数<code>reject</code>不具备”拆箱“的能力，reject的参数会直接传递给<code>then</code>方法中的<code>rejected</code>回调。因此，即使p3 <code>reject</code>接收了一个resolved状态的Promise，<code>then</code>方法中被调用的依然是<code>rejected</code>，并且参数就是<code>reject</code>接收到的Promise对象。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】作用域链与原型链</title>
    <url>/2019/04/20/%E3%80%90JS%E3%80%91%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>原文链接 <a href="https://www.cnblogs.com/pssp/p/5204324.html" target="_blank" rel="noopener">https://www.cnblogs.com/pssp/p/5204324.html</a></p>
<h3 id="什么是作用域链，什么是原型链。"><a href="#什么是作用域链，什么是原型链。" class="headerlink" title="什么是作用域链，什么是原型链。"></a>什么是作用域链，什么是原型链。</h3><p>　　作用域是针对变量的，比如我们创建了一个函数，函数里面又包含了一个函数，那么现在就有三个作用域</p>
<p>　　全局作用域==&gt;函数1作用域==&gt;函数2作用域</p>
<p>作用域的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>



<p>最后打印出来的是3，因为执行函数c（）的时候它在自己的范围内找到了变量a所以就不会越上继续查找，如果在函数c()中没有找到则会继续向上找，一直会找到全局变量a，这个查找的过程就叫作用域链。</p>
<p>不知道你有没有疑问，函数c为什么可以在函数b中查找变量a，因为函数c是在函数b中创建的，也就是说函数c的作用域包括了函数b的作用域，当然也包括了全局作用域，但是函数b不能向函数c中查找变量，因为作用域只会向上查找。</p>
<p>那么什么是原型链呢？</p>
<p>　　原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的属性，然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。</p>
<p>　　Object ==&gt; 构造函数1 ==&gt; 构造函数2</p>
<p>　　就和css中的继承一样，如果自身没有定义就会继承父元素的样式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">a.prototype.name = <span class="string">"追梦子"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> a();</span><br><span class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】判断客户端类型</title>
    <url>/2019/05/22/%E3%80%90JS%E3%80%91%E5%88%A4%E6%96%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JS-判断客户端是iOS还是Android"><a href="#JS-判断客户端是iOS还是Android" class="headerlink" title="JS 判断客户端是iOS还是Android"></a>JS 判断客户端是iOS还是Android</h1><blockquote>
<p>判断的逻辑是：客户端不是Android，就是iOS，就是PC，其实还有黑莓BlackBerry、塞班SymbianOS、Windows Phone等，如果需要可自行添加，我在第三条有写。</p>
</blockquote>
<h2 id="通过浏览器的-navigator-userAgent-判断是Android还是iOS："><a href="#通过浏览器的-navigator-userAgent-判断是Android还是iOS：" class="headerlink" title="通过浏览器的 navigator.userAgent 判断是Android还是iOS："></a>通过浏览器的 navigator.userAgent 判断是Android还是iOS：</h2><h3 id="一-判断是Android还是iOS"><a href="#一-判断是Android还是iOS" class="headerlink" title="一. 判断是Android还是iOS"></a>一. 判断是Android还是iOS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">let</span> isAndroid = u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>;   <span class="comment">//判断是否是 android终端</span></span><br><span class="line"><span class="keyword">let</span> isIOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);     <span class="comment">//判断是否是 iOS终端</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'是否是Android：'</span>, isAndroid); <span class="comment">//true,false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'是否是iOS：'</span>, isIOS)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>封装成方法：</p>
<p>``  /<em>判断客户端</em>/<br>  judgeClient() {</p>
<pre><code>let u = navigator.userAgent;
let isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Adr&apos;) &gt; -1;   //判断是否是 android终端
let isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);     //判断是否是 iOS终端
console.log(&apos;是否是Android：&apos; + isAndroid); //true,false
console.log(&apos;是否是iOS：&apos; + isIOS);
if(isAndroid){
  return &apos;Android&apos;;
}else if(isIOS){
  return &apos;IOS&apos;;
}else{
  return &apos;PC&apos;;
}</code></pre><p>  },```</p>
</li>
</ul>
<h3 id="二-判断是Android还是iOS"><a href="#二-判断是Android还是iOS" class="headerlink" title="二.判断是Android还是iOS"></a>二.判断是Android还是iOS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(iPhone|iPad|iPod|iOS)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isIOS'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/(Android)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isAndroid'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isPC'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">*   封装成方法：</span><br><span class="line">      <span class="comment">/*判断客户端*/</span></span><br><span class="line">      judgeClient() &#123;</span><br><span class="line">        <span class="keyword">let</span> client = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/(iPhone|iPad|iPod|iOS)/i</span>.test(navigator.userAgent)) &#123;  <span class="comment">//判断iPhone|iPad|iPod|iOS</span></span><br><span class="line">          client = <span class="string">'iOS'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/(Android)/i</span>.test(navigator.userAgent)) &#123;  <span class="comment">//判断Android</span></span><br><span class="line">          client = <span class="string">'Android'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          client = <span class="string">'PC'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="三-判断PC还是移动端"><a href="#三-判断PC还是移动端" class="headerlink" title="三.判断PC还是移动端"></a>三.判断PC还是移动端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isPC() &#123;</span><br><span class="line">  <span class="comment">/*true则pc，false则mobile*/</span></span><br><span class="line">  <span class="keyword">let</span> u = navigator.userAgent;</span><br><span class="line">  <span class="keyword">let</span> Agents = [<span class="string">"Android"</span>, <span class="string">"iPhone"</span>, <span class="string">"webOS"</span>, <span class="string">"BlackBerry"</span>, <span class="string">"SymbianOS"</span>, <span class="string">"Windows Phone"</span>, <span class="string">"iPad"</span>, <span class="string">"iPod"</span>];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; Agents.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (u.indexOf(Agents[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<h3 id="四-判断多种访问终端"><a href="#四-判断多种访问终端" class="headerlink" title="四.判断多种访问终端"></a>四.判断多种访问终端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//判断访问终端</span></span><br><span class="line">    <span class="keyword">let</span> browser = &#123;</span><br><span class="line">      versions: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          trident: u.indexOf(<span class="string">'Trident'</span>) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span><br><span class="line">          presto: u.indexOf(<span class="string">'Presto'</span>) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span><br><span class="line">          webKit: u.indexOf(<span class="string">'AppleWebKit'</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">          gecko: u.indexOf(<span class="string">'Gecko'</span>) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(<span class="string">'KHTML'</span>) == <span class="number">-1</span>,<span class="comment">//火狐内核</span></span><br><span class="line">          mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">          ios: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">          android: u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>, <span class="comment">//android终端</span></span><br><span class="line">          iPhone: u.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">          iPad: u.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">          webApp: u.indexOf(<span class="string">'Safari'</span>) == <span class="number">-1</span>, <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">          weixin: u.indexOf(<span class="string">'MicroMessenger'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否微信</span></span><br><span class="line">          qq: u.match(<span class="regexp">/\sQQ/i</span>) == <span class="string">" qq"</span> <span class="comment">//是否QQ</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;(),</span><br><span class="line">      language: (navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (browser.versions.mobile) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"is mobile"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (browser.versions.ios) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"is ios"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="五-判断浏览器当前使用的语言"><a href="#五-判断浏览器当前使用的语言" class="headerlink" title="五.判断浏览器当前使用的语言"></a>五.判断浏览器当前使用的语言</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">judgeLanguage() &#123;</span><br><span class="line">  <span class="comment">// 判断浏览器当前使用的语言</span></span><br><span class="line">  <span class="keyword">let</span> currentLanguage = (navigator.browserLanguage || navigator.language).toLowerCase();    <span class="comment">// 非IE</span></span><br><span class="line">  <span class="keyword">if</span> (!currentLanguage) &#123;    <span class="comment">// IE浏览器</span></span><br><span class="line">    currentLanguage = navigator.browserLanguage;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(currentLanguage);</span><br><span class="line">  <span class="keyword">return</span> currentLanguage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】判断数据类型的方法</title>
    <url>/2019/05/20/%E3%80%90JS%E3%80%91%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对js中不同数据的布尔值类型总结：false:空字符串；null；undefined；0；NaN。<br>true：除了上面的false的情况其他都为true；</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkBoolean</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(a)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="string">''</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="literal">null</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="literal">undefined</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(<span class="literal">NaN</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(a));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(checkBoolean(c));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>javascript中有六种数据类型：string；boolean；Array；Object；null;undefined。如何检测这些数据类型呢，总结方法如下：</p>
<p><strong>方法一：采用typeof</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = \[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>\];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">123</span>,</span><br><span class="line">    b:<span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;       <span class="keyword">var</span> u = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">//方法一使用typeof方法。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);<span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);<span class="comment">//null是一个空的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn);<span class="comment">//function</span></span><br></pre></td></tr></table></figure>


<p>通过上面的检测我们发现typeof检测的Array和Object的返回类型都是Object，因此用typeof是无法检测出来数组和对象的，采用方法二和方法三则可以检测出来。</p>
<p><strong>方法二：instanceof</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//  false</span></span><br></pre></td></tr></table></figure>


<p> 注意：instaceof只可以用来判断数组和对象，不能判断string和boolean类型，要判断string和boolean类型需要采用方法四。<br> 由于数组也属于对象因此我们使用instanceof判断一个数组是否为对象的时候结果也会是true。如：</p>
<p>console.log(a instanceof Object);//true。</p>
<p>下面封装一个方法进行改进：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="keyword">var</span> getDataType = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Array'</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( o <span class="keyword">instanceof</span> <span class="built_in">Object</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Object'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'param is no object type'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getDataType(o));<span class="comment">//Object。</span></span><br><span class="line"><span class="built_in">console</span>.log(getDataType(a));<span class="comment">//Array。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用constructor方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">           <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor == <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.constructor == <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>方法四：利用tostring()方法，这个方法是最佳的方案。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">          <span class="string">'name'</span>:<span class="string">'lee'</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">var</span> a = \[<span class="string">'reg'</span>,<span class="string">'blue'</span>\];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> c(<span class="string">'kingw'</span>,<span class="string">'27'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a));<span class="comment">//\[object Array\]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(o));<span class="comment">//\[Object Object\]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(c));<span class="comment">//\[Object Object\]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个方法判断数组和对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> type = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">       <span class="keyword">if</span>(type == <span class="string">'\[object Array\]'</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">'Array'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">'\[object Object\]'</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"Object"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">'param is no object type'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isType(o));<span class="comment">//Object</span></span><br><span class="line"><span class="built_in">console</span>.log(isType(a));<span class="comment">//Array</span></span><br></pre></td></tr></table></figure>

<p><strong>方法五：利用jquery的$.isPlainObject();$.isArray(obj);$.isFunction(obj)进行判断。</strong></p>
<p> 出处：<a href="http://www.cnblogs.com/xinggood" target="_blank" rel="noopener">http://www.cnblogs.com/xinggood</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收内存泄漏</title>
    <url>/2019/05/02/%E3%80%90JS%E3%80%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><ol>
<li>分配你所需要的内存：</li>
</ol>
<p>由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会<strong>分配内存来存储那个实体</strong>。</p>
<ol start="2">
<li><p>使用分配到的内存做点什么。</p>
</li>
<li><p>不需要时将其释放回归：</p>
</li>
</ol>
<p>在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是<strong>垃圾回收机制所存在的意义</strong>。</p>
<p><strong>所谓的内存泄漏指的是</strong>：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>在C和C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。</p>
<h3 id="垃圾收集机制的原理"><a href="#垃圾收集机制的原理" class="headerlink" title="垃圾收集机制的原理"></a>垃圾收集机制的原理</h3><p><strong>垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存</strong>。</p>
<p><strong>什么叫不再继续使用的变量？</strong></p>
<p>不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</p>
<p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说<strong>全局变量不会被当成垃圾回收</strong>。</p>
<h3 id="标记清除：当前采用的垃圾收集策略"><a href="#标记清除：当前采用的垃圾收集策略" class="headerlink" title="标记清除：当前采用的垃圾收集策略"></a>标记清除：当前采用的垃圾收集策略</h3><p>工作原理：</p>
<p>当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
<p>工作流程：</p>
<ol>
<li>垃圾收集器会在运行的时候会给存储在内存中的<strong>所有变量都加上标记</strong>。</li>
<li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>
<li>那些还存在标记的变量被视为准备删除的变量。</li>
<li>最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<p>到2008年为止,IE、Chorme、Fireofx、Safari、Opera <strong>都使用标记清除式的垃圾收集策略</strong>，只不过垃圾收集的时间间隔互有不同。</p>
<h3 id="引用计数略：被废弃的垃圾收集策"><a href="#引用计数略：被废弃的垃圾收集策" class="headerlink" title="引用计数略：被废弃的垃圾收集策"></a>引用计数略：被废弃的垃圾收集策</h3><p>循环引用：跟踪记录每个值被引用的技术</p>
<p>在老版本的浏览器中(对，又是IE)，IE9以下BOM和DOM对象就是使用C++以COM对象的形式实现的。</p>
<p>COM的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'something'</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element; <span class="comment">// element属性指向dom</span></span><br><span class="line">element.someThing = myObject; <span class="comment">// someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。</span></span><br></pre></td></tr></table></figure>
<p>解决方式是，当我们不使用它们的时候，手动切断链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>; </span><br><span class="line">element.someThing = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><strong>淘汰</strong>：</p>
<p>IE9把BOM和DOM对象转为了真正的js对象，避免了使用这种垃圾收集策略，消除了IE9以下常见的内存泄漏的主要原因。</p>
<p>IE7以下有一个声明狼藉的性能问题，大家了解一下：</p>
<ol>
<li>256个变量，4096个对象(或数组)字面或者64KB的字符串，达到任何一个临界值会触发垃圾收集器运行。</li>
<li>如果一个js脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。</li>
</ol>
<p>IE7已修复这个问题。</p>
<h2 id="哪些情况会引起内存泄漏"><a href="#哪些情况会引起内存泄漏" class="headerlink" title="哪些情况会引起内存泄漏"></a>哪些情况会引起内存泄漏</h2><p>虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。</p>
<h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><p>上文我们提到了<strong>全局变量不会被当成垃圾回收</strong>，我们在编码中有时会出现下面这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.bar2 = <span class="string">'默认绑定this指向全局'</span> <span class="comment">// 全局变量=&gt; window.bar2</span></span><br><span class="line">  bar = <span class="string">'全局变量'</span>; <span class="comment">// 没有声明变量 实际上是全局变量=&gt;window.bar</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>当我们使用<a href="https://juejin.im/post/5b3715def265da59af40a630#heading-3" target="_blank" rel="noopener">默认绑定</a>，this会指向全局，<code>this.something</code>也会创建一个全局变量，这一点可能很多人没有注意到。</p>
<p><strong>解决方法：在函数内使用严格模式or细心一点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>; </span><br><span class="line">  <span class="keyword">this</span>.bar2 = <span class="string">"严格模式下this指向undefined"</span>; </span><br><span class="line">  bar = <span class="string">"报错"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>当然我们也可以<strong>手动释放全局变量的内存</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.bar = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.bar2</span><br></pre></td></tr></table></figure>
<h3 id="被遗忘的定时器和回调函数"><a href="#被遗忘的定时器和回调函数" class="headerlink" title="被遗忘的定时器和回调函数"></a>被遗忘的定时器和回调函数</h3><p>当<strong>不需要</strong><code>setInterval</code>或者<code>setTimeout</code>时，<strong>定时器没有被clear</strong>，定时器的<strong>回调函数以及内部依赖的变量都不能被回收</strong>，造成内存泄漏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">        <span class="comment">// 定时器也没有清除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node、someResource 存储了大量数据 无法回收</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>： 在定时器完成工作的时候，手动清除定时器。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(obj,<span class="string">'闭包内引用obj obj不会被释放'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// obj = null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：手动解除引用，<code>obj = null</code>。</p>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>就是IE9以下的循环引用问题，上文讲过了。</p>
<h3 id="没有清理DOM元素引用"><a href="#没有清理DOM元素引用" class="headerlink" title="没有清理DOM元素引用"></a>没有清理DOM元素引用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">'refA'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">"refA"</span>);  <span class="comment">// 但是还存在引用 能console出整个div 没有被回收</span></span><br></pre></td></tr></table></figure>
<p>不信的话，可以看下这个<a href="https://codepen.io/OBKoro1/pen/vroKbg" target="_blank" rel="noopener">dom</a>。</p>
<p><strong>解决办法</strong>：refA = null;</p>
<h3 id="console保存大量数据在内存中"><a href="#console保存大量数据在内存中" class="headerlink" title="console保存大量数据在内存中"></a>console保存大量数据在内存中</h3><p>过多的console，比如定时器的console会导致浏览器卡死。</p>
<p><strong>解决</strong>：合理利用console，线上项目尽量少的使用console，当然如果你要发招聘，除外。</p>
<h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p><strong>记住一个原则：不用的东西，及时归还，毕竟你是’借的’嘛</strong>。</p>
<ol>
<li>减少不必要的全局变量，使用严格模式避免意外创建全局变量。</li>
<li>在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。</li>
<li>组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</li>
</ol>
<h3 id="关于内存泄漏"><a href="#关于内存泄漏" class="headerlink" title="关于内存泄漏"></a>关于内存泄漏</h3><ol>
<li>即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。</li>
<li>一般是堆区内存泄漏，栈区不会泄漏。</li>
</ol>
<p>基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以<strong>对象、数组之类的，才会发生内存泄漏</strong>。</p>
<ol start="3">
<li>使用chorme监控内存泄漏</li>
</ol>
<p>转自<a href="http://obkoro1.com/" target="_blank" rel="noopener">http://obkoro1.com/</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的正则表达式</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> . 校验密码强度</span><br><span class="line">密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="number">8</span><span class="number">-10</span>之间。</span><br><span class="line">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 校验中文</span><br><span class="line">字符串仅能是中文。</span><br><span class="line">^[\\u4e00-\\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 由数字、<span class="number">26</span>个英文字母或下划线组成的字符串</span><br><span class="line">^\\w+$</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 校验E-Mail 地址</span><br><span class="line">同密码一样，下面是E-mail地址合规性的正则检查语句。</span><br><span class="line">[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 校验身份证号码</span><br><span class="line">下面是身份证号码的正则校验。<span class="number">15</span> 或 <span class="number">18</span>位。</span><br><span class="line"><span class="number">15</span>位：</span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">18</span>位：</span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;([<span class="number">0</span><span class="number">-9</span>]|X)$</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 校验日期</span><br><span class="line">“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</span><br><span class="line">^(?:(?!<span class="number">0000</span>)[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">4</span>&#125;-(?:(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-8</span>])|(?:<span class="number">0</span>[<span class="number">13</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">29</span>|<span class="number">30</span>)|(?:<span class="number">0</span>[<span class="number">13578</span>]|<span class="number">1</span>[<span class="number">02</span>])<span class="number">-31</span>)|(?:[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])|(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])<span class="number">00</span>)<span class="number">-02</span><span class="number">-29</span>)$</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 校验金额</span><br><span class="line">金额校验，精确到<span class="number">2</span>位小数。</span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 校验手机号</span><br><span class="line">下面是国内 <span class="number">13</span>、<span class="number">15</span>、<span class="number">18</span>开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</span><br><span class="line">^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 判断IE的版本</span><br><span class="line">IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</span><br><span class="line">^.*MSIE [<span class="number">5</span><span class="number">-8</span>](?:\\.[<span class="number">0</span><span class="number">-9</span>]+)?(?!.*Trident\\/[<span class="number">5</span><span class="number">-9</span>]\\<span class="number">.0</span>).*$</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 校验IP-v4地址</span><br><span class="line">IP4 正则语句。</span><br><span class="line">\\b(?:(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)\\.)&#123;<span class="number">3</span>&#125;(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)\\b</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> 校验IP-v6地址</span><br><span class="line">IP6 正则语句。</span><br><span class="line">(([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;|[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;)|:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;|:)|fe80:(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">0</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">4</span>&#125;%[<span class="number">0</span><span class="number">-9</span>a-zA-Z]&#123;<span class="number">1</span>,&#125;|::(ffff(:<span class="number">0</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;:)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>]))</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> 检查URL的前缀</span><br><span class="line">应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</span><br><span class="line"><span class="keyword">if</span> (!s.match(<span class="regexp">/^[a-zA-Z]+:\\/</span>\\<span class="comment">//))</span></span><br><span class="line">&#123;</span><br><span class="line">    s = <span class="string">'http://'</span> + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 提取URL链接</span><br><span class="line">下面的这个表达式可以筛选出一段文本中的URL。</span><br><span class="line">^(f|ht)&#123;<span class="number">1</span>&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> 文件路径及扩展名校验</span><br><span class="line">验证windows下文件路径和扩展名（下面的例子中为.txt文件）</span><br><span class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?<span class="string">"&lt;&gt;|]+\\.txt(l)?$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">15. 提取Color Hex  Codes</span></span><br><span class="line"><span class="string">有时需要抽取网页中的颜色代码，可以使用下面的表达式。</span></span><br><span class="line"><span class="string">^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">16. 提取网页图片</span></span><br><span class="line"><span class="string">假若你想提取网页中所有图片信息，可以利用下面的表达式。</span></span><br><span class="line"><span class="string">\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\"</span>\\<span class="string">']&#123;0,1&#125;([^\\"\\'</span>\\ &gt;]*)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> 提取页面超链接</span><br><span class="line">提取html中的超链接。</span><br><span class="line">(<span class="xml"><span class="tag">&lt;<span class="name">a\\s*(?!.*\\brel=)[^</span>&gt;</span>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">18. 查找CSS属性</span></span><br><span class="line"><span class="xml">通过下面的表达式，可以搜索到相匹配的CSS属性。</span></span><br><span class="line"><span class="xml">^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">19. 抽取注释</span></span><br><span class="line"><span class="xml">如果你需要移除HMTL中的注释，可以使用如下的表达式。</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--(.*?)--&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">20. 匹配HTML标签</span></span><br><span class="line"><span class="xml">通过下面的表达式可以匹配出HTML中的标签属性。</span></span><br><span class="line">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'"&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】监听页面的后退返回(移动端PC端)</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%90%8E%E9%80%80%E8%BF%94%E5%9B%9E(%E7%A7%BB%E5%8A%A8%E7%AB%AFPC%E7%AB%AF)/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">pushHistory</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> state = &#123;</span><br><span class="line">            title: <span class="string">"title"</span>,</span><br><span class="line">            url: <span class="string">"#"</span> &#125;;</span><br><span class="line">        <span class="built_in">window</span>.history.pushState(state, <span class="string">"title"</span>, <span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushHistory();</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"popstate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"我监听到了浏览器的返回按钮事件啦"</span>); <span class="comment">// 根据自己的需求实现自己的功能</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2019/04/18/%E3%80%90JS%E3%80%91%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(o) <span class="keyword">return</span> &#123;</span><br><span class="line">  fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123; <span class="keyword">return</span> fun(m,n);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; <span class="keyword">var</span> a = fun(<span class="number">0</span>); a.fun(<span class="number">1</span>); a.fun(<span class="number">2</span>); a.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>); c.fun(<span class="number">2</span>); c.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,? //问:三行a,b,c的输出分别是什么？</span></span><br></pre></td></tr></table></figure>

<p>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</p>
<p>可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？</p>
<p><strong>答案</strong></p>
<p>//a: undefined,0,0,0 //b: undefined,0,1,2 //c: undefined,0,1,1</p>
<p>都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了；如果没有答案，继续往下分析。</p>
<p><strong>JS中有几种函数</strong></p>
<p>首先，在此之前需要了解的是，在JS中函数可以分为两种，具名函数（命名函数）和匿名函数。</p>
<p>区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数</p>
<p><strong>注意：</strong>在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试</p>
<p>或是采用兼容IE的获取函数name方法来获取函数名称：</p>
<p>/**<br>  * 获取指定函数的函数名称（用于兼容IE）<br>  * @param {Function} fun 任意函数 */<br>function getFunctionName(fun) { if (fun.name !== undefined) return fun.name; var ret = fun.toString();<br>  ret = ret.substr(‘function ‘.length);<br>  ret = ret.substr(0, ret.indexOf(‘(‘)); return ret;<br>}</p>
<p>遂用上述函数测试是否为匿名函数：</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161154422.png?2015102516123" alt=""></p>
<p>可以得知变量fn1是具名函数，fn2是匿名函数</p>
<p><strong>创建函数的几种方式</strong></p>
<p>说完函数的类型，还需要了解JS中创建函数都有几种创建方法。</p>
<p><strong>1、声明函数</strong></p>
<p>最普通最标准的声明函数方法，包括函数名及函数体。</p>
<p><strong>function fn1(){}</strong></p>
<p><strong>2、创建匿名函数表达式</strong></p>
<p>创建一个变量，这个变量的内容为一个函数</p>
<p><strong>var fn1=function (){}</strong><br>注意采用这种方法创建的函数为匿名函数，即没有函数name</p>
<p>var fn1=function (){};<br>getFunctionName(fn1).length;//0</p>
<p><strong>3、创建具名函数表达式</strong></p>
<p>创建一个变量，内容为一个带有名称的函数</p>
<p><strong>var fn1=function xxcanghai(){};</strong><br><strong>注意：</strong>具名函数表达式的函数名只能在创建函数内部使用</p>
<p>即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用</p>
<p>测试：</p>
<p>var fn1=function xxcanghai(){<br>  console.log(“in:fn1&lt;”,typeof fn1,”&gt;xxcanghai:&lt;”,typeof xxcanghai,”&gt;”);<br>};<br>console.log(“out:fn1&lt;”,typeof fn1,”&gt;xxcanghai:&lt;”,typeof xxcanghai,”&gt;”);<br>fn1(); //out:fn1&lt; function &gt;xxcanghai:&lt; undefined &gt; //in:fn1&lt; function &gt;xxcanghai:&lt; function &gt;</p>
<p>可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。</p>
<p><strong>注意：</strong>在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</p>
<p><strong>4、Function构造函数</strong></p>
<p>可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是匿名函数。</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161355276.png?2015102516143" alt=""></p>
<p><strong>5、自执行函数</strong></p>
<p>(function(){alert(1);})();<br>(function fn1(){alert(1);})();</p>
<p>自执行函数属于上述的“函数表达式”，规则相同</p>
<p> <strong>6、其他创建函数的方法</strong></p>
<p>当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 <strong>eval ， setTimeout ， setInterval</strong> 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开</p>
<p><strong>三个fun函数的关系是什么？</strong></p>
<p>说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。</p>
<p>这段代码中出现了三个fun函数，所以第一步先搞清楚，这三个fun函数的关系，哪个函数与哪个函数时相同的。</p>
<p>function fun(n,o) {<br> console.log(o) return {<br>  fun:function(m){ //…<br> }<br> };<br>}</p>
<p>先看第一个fun函数，属于标准具名函数声明，是新创建的函数，他的返回值是一个对象字面量表达式，属于一个新的object。</p>
<p>这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。</p>
<p><strong>注意：</strong>所有声明的匿名函数都是一个新函数。</p>
<p>所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。</p>
<p><strong>函数作用域链的问题</strong></p>
<p>再说第三个fun函数之前需要先说下，在函数表达式内部能不能访问存放当前函数的变量。</p>
<p><strong>测试1：对象内部的函数表达式：</strong></p>
<p>var o={<br> fn:function (){<br>  console.log(fn);<br> }<br>};<br>o.fn();//ERROR报错</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161534228.png?20151025161556" alt=""></p>
<p><strong>测试2：非对象内部的函数表达式：</strong></p>
<p>var fn=function (){<br> console.log(fn);<br>};<br>fn();//function (){console.log(fn);};正确</p>
<p><img src="https://files.jb51.net/file_images/article/201511/20151125161644557.png?20151025161652" alt=""></p>
<p><strong>结论：</strong>使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。</p>
<p>原因也非常简单，因为函数作用域链的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。</p>
<p>所以综上所述，可以得知，最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。</p>
<p>所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。</p>
<p><strong>到底在调用哪个函数？</strong></p>
<p>再看下原题，现在知道了程序中有两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？</p>
<p>function fun(n,o) {<br> console.log(o) return {<br>  fun:function(m){ return fun(m,n);<br>  }<br> };<br>} var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined,?,?,?<br>var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?<br>var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,? //问:三行a,b,c的输出分别是什么？</p>
<p><strong>1、第一行a</strong></p>
<p>*<em>var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);<br>*</em>可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：</p>
<p>第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用fun(0)时，o为undefined；</p>
<p>第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0</p>
<p>第四次同理；</p>
<p>即：最终答案为undefined,0,0,0</p>
<p><strong>2、第二行b</strong></p>
<p>*<em>var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?<br>*</em>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；</p>
<p>第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；</p>
<p>即最终答案：undefined,0,1,2</p>
<p> <strong>3、第三行c</strong></p>
<p>*<em>var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?<br>*</em>根据前面两个例子，可以得知：</p>
<p>fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；</p>
<p>第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1</p>
<p>即最终答案：undefined,0,1,1</p>
<p>后话</p>
<p>这段代码原本是在做一个将异步回调改写为同步调用的组件时的代码，发现了这个坑，对JS的闭包有了更深入的了解。</p>
<p>关于什么是闭包，网上的文章数不胜数，但理解什么是闭包还是要在代码中自己去发现与领悟。</p>
<p>如果要我说什么是闭包，我认为，广义上的闭包就是指一个变量在他自身作用域的被使用了，就叫发生了闭包。</p>
<p>转      <a href="https://www.jb51.net/article/75450.htm" target="_blank" rel="noopener">https://www.jb51.net/article/75450.htm</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】vuecli3 favicon 的修改</title>
    <url>/2019/04/20/%E3%80%90Vue%E3%80%91vuecli3%20favicon%20%E7%9A%84%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>在vue.config.js中配置pwa，重跑下项目就行了 // 以下是pwa配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pwa: &#123;</span><br><span class="line">     iconPaths: &#123;</span><br><span class="line">       favicon32     : <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       favicon16     : <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       appleTouchIcon: <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       maskIcon      : <span class="string">'faviconfc.ico'</span>,</span><br><span class="line">       msTileImage   : <span class="string">'faviconfc.ico'</span> &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【js】判断字符串中是否包含某个字符串</title>
    <url>/2019/05/20/%E3%80%90js%E3%80%91%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="String对象方法"><a href="#String对象方法" class="headerlink" title="String对象方法"></a>String对象方法</h3><p>方法一: indexOf()   (推荐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"3"</span>) != <span class="number">-1</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。</p>
<p>方法二: search() </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">"3"</span>) != <span class="number">-1</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</p>
<p>方法三:match()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(str.match(reg))&#123;</span><br><span class="line">    <span class="comment">// 包含        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<h3 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h3><p>方法四:test() </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>test() 方法用于检索字符串中指定的值。返回 true 或 false。</p>
<p>方法五:exec()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(reg.exec(str))&#123;</span><br><span class="line">    <span class="comment">// 包含        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<p><a href="https://www.cnblogs.com/ooo0/p/7741651.html" target="_blank" rel="noopener">https://www.cnblogs.com/ooo0/p/7741651.html</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】关于 vue动态绑定class的几种方式</title>
    <url>/2019/04/20/%E3%80%90Vue%E3%80%91%E5%85%B3%E4%BA%8E%20vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>###对象方法<br>-最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）</p>
<p>：class=“{‘active’:isTrue}”</p>
<p>判断是否绑定一个active</p>
<p>:class=“{‘active’:isActive==-1}” 或者<br>:class=“{‘active’:isActive==index}”</p>
<p>绑定并判断多个</p>
<p>第一种（用逗号隔开）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; 'active': isActive, 'sort': isSort &#125;"</span></span><br></pre></td></tr></table></figure>
<p>第二种（放在data里面）<br>//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span> data() &#123; <span class="keyword">return</span> &#123;</span><br><span class="line">        classObject:&#123; <span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">sort</span>:<span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种（使用computed属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span> data() &#123; <span class="keyword">return</span> &#123;</span><br><span class="line">        isActive: <span class="literal">true</span>,</span><br><span class="line">        isSort: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">    classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;</span><br><span class="line">          active: <span class="keyword">this</span>.isActive,</span><br><span class="line">          sort:<span class="keyword">this</span>.isSort</span><br><span class="line">       &#125;</span><br><span class="line">          </span><br><span class="line">　　&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">###数组方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单纯数组</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"\[isActive,isSort\]"</span> data() &#123; <span class="keyword">return</span>&#123;</span><br><span class="line">    isActive:<span class="string">'active'</span>,</span><br><span class="line">    isSort:<span class="string">'sort'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组与三元运算符结合判断选择需要的class<br>（注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"\[isActive?'active':''\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[isActive==1?'active':''\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[isActive==index?'active':''\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[isActive==index?'active':'otherActiveClass'\]"</span></span><br></pre></td></tr></table></figure>
<p>数组对象结合动态判断<br>//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p>
<p>//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"\[&#123; active: isActive &#125;, 'sort'\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[&#123; active: isActive==1 &#125;, 'sort'\]"</span> 或者</span><br><span class="line">:<span class="class"><span class="keyword">class</span>\</span>=<span class="string">"\[&#123; active: isActive==index &#125;, 'sort'\]"</span></span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/qq\_43077894/article/details/83544399" target="_blank" rel="noopener">https://blog.csdn.net/qq\_43077894/article/details/83544399</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【vue】 vuecli3 打包</title>
    <url>/2019/07/20/%E3%80%90vue%E3%80%91%20vuecli3%20%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>vue-cli3 打包后 路径错误</p>
<p>1、新建 vue.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,    </span><br><span class="line">    lintOnSave:<span class="literal">false</span>     <span class="comment">//关闭eslint </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、router mode模式 设置为 hash</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【vue】代理方式跨域</title>
    <url>/2019/07/20/%E3%80%90vue%E3%80%91%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>前端使用代理主要用于跨域请求，</p>
<p>关于跨域：常用的方式</p>
<ul>
<li><p>JSONP：利用script标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数。</p>
</li>
<li><p>CORS：服务器设置HTTP响应头中Access-Control-Allow-Origin值，解除跨域限制    </p>
</li>
</ul>
<p>但是这两个跨域方案都存在一个致命的缺陷，严重依赖后端的协助，</p>
<p>代理 就可以作为 前端独立解决跨域的方案</p>
<p><strong>正向代理</strong></p>
<p>是指一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。</p>
<p> 　　vue-cli 3.x  新建vue.config.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123; <span class="comment">// proxy all requests starting with /api to jsonplaceholder</span></span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:8080'</span>,   <span class="comment">//代理接口</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">'/mock'</span>    <span class="comment">//代理的路径</span></span><br><span class="line"> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反向代理</strong></p>
<p>反向代理（Reverse Proxy）是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p><a href="https://www.cnblogs.com/softidea/p/7425894.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/7425894.html</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【vue】手动实现一个基础双向绑定</title>
    <url>/2019/04/20/%E3%80%90vue%E3%80%91%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">v-model</span>=<span class="string">'message'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind</span>=<span class="string">'message'</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="actionscript">        message:<span class="string">''</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'[v-model=message]'</span>)</span></span><br><span class="line"><span class="actionscript">    input.onkeyup=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        data.message = input.value</span><br><span class="line"><span class="actionscript">        <span class="comment">// data.message 发生改变 触发 Object.defineproperty</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">//Object.defineProperty 接受三个参数 </span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// obj 要在其上定义属性的对象。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// prop 要定义或修改的属性的名称。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// descriptor 将被定义或修改的属性描述符。 仅用到 get 和 set 属性　　 // 这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象。</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(data, <span class="string">'message'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// set 接受唯一参数，即该属性新的参数值。</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">set</span>(newValue)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">'[v-bind=message]'</span>)</span></span><br><span class="line"><span class="actionscript">            span.innerHTML=newValue　　　　　　　<span class="keyword">this</span>.value = newValue</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">// get 方法执行时没有参数传入</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">get</span>()&#123;　　　　     <span class="comment">//将newValue 返回给 message</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="keyword">this</span>.value</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【webpack】urlloader 图片路径问题</title>
    <url>/2019/04/10/%E3%80%90webpack%E3%80%91urlloader%20%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="webpack-url-loader-图片路径问题"><a href="#webpack-url-loader-图片路径问题" class="headerlink" title="webpack:url-loader 图片路径问题"></a>webpack:url-loader 图片路径问题</h3><p>我们使用webpack打包项目中，在处理图片路径时， 最常用的loader有两种， url-loader 和 file-loader。</p>
<p>我们在写项目中引用路径的时候，填写的URL是基于我们开发时的路径， 但是在webpack打包时， 会将各个模块打包成一个文件，里面引用的路径是相对于入口html文件，并不是相对于我们的原始文件路径的。loader 可以解析项目中引入的URL，并且根据配置，把图片拷贝到相应路径， 再将打包后的文件中的路径 替换为图像的最终路径。</p>
<p>file-loader 和 url-loader 都可以解决这个问题。 但是url-loader会将引入的图片进行编码， 我们引用的时候只需要引入这个文件就可以访问图片了， 可以大大减少 HTTP请求的次数。</p>
<p>url-loader 封装了 file-loader， 但并不依赖他， 所以我们可以只需要安装 url-loader就可以了。</p>
<p>在使用url-loader时，出现了 路径引用错误的 情况。</p>
<ol>
<li>问题复现</li>
</ol>
<p>webpack.prod.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'url-loader'</span>, <span class="comment">//是指定使用的loader和loader的配置参数</span></span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit:<span class="number">500</span>,  <span class="comment">//是把小于500B的文件打成Base64的格式，写入JS</span></span><br><span class="line">                    name: <span class="string">'images/[name]_[hash:7].[ext]'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(css)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.scss'</span>;</span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.png'</span>;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    Hello world</span><br><span class="line">        </span><br><span class="line">    ,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>index.css</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#root &#123;</span><br><span class="line">    color: aqua;</span><br><span class="line">    background: url(<span class="string">'./logo.png'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后的 css 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#root&#123;background:url(images&#x2F;logo_e179a47.png);color:#0ff&#125;</span><br></pre></td></tr></table></figure>

<p>打包后 的 文件结构</p>
<p>── css</p>
<p>│   └── app.9fd7e730df40df61cc5a.css</p>
<p>├── images</p>
<p>│   └── logo_e179a47.png</p>
<p>├── js</p>
<p>│  └── app.382da24eb9c30ee2.js</p>
<p>└── index.html</p>
<p>我们在浏览器中打开打包后的 index.html</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f420ecd33c50?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>可以看出我们在index.js 中 引入的图片是可以正常加载的， 但是我们在css中引入的背景图 并没有加载成功。</p>
<ol start="2">
<li>问题原因</li>
</ol>
<p>webpack 在 打包时， 首先会把图片 复制到 /dist/images/ 文件夹下， 然后把 css 文件中的url 路径 替换为webpack中options的name属性指向的路径，即 /images/logo.png, 但是这个路径是相对路径，是相对于 /dist/css/~.css 来说的， 所以此处引用的 文件地址为： /dist/css/images/logo.jpg。 但是我们打包后的css 文件夹中， 并没有 images/logo.png, 所以图片并没有渲染出来。 但是 对于 我们 index.js 中 引用的图片， 此处相对路径是相对于 index.html 来说的， 所以 是可以取到图片的。</p>
<ol start="3">
<li>解决方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: <span class="regexp">/\.(css)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">                publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在为css文件配置 loader时， 添加 publicPath 属性。 这样做， 我们在图片打包时， 仍会将图片复制在 /dist/images/ 文件夹之下， 但是 在css文件中引用时， 会将路径替换为 publicPath + name。</p>
<p>打包后的 css 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#root&#123;background:url(..&#x2F;images&#x2F;logo_e179a47.png);color:#0ff&#125;</span><br></pre></td></tr></table></figure>

<p>至此， 项目中 css 的文件引用路径 和 js 中的文件引用路径 均为正确的图片路径。</p>
<p><a href="https://juejin.im/post/5b8d1e926fb9a019b66e4657" target="_blank" rel="noopener">https://juejin.im/post/5b8d1e926fb9a019b66e4657</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【webpack】webpack基本配置</title>
    <url>/2019/04/10/%E3%80%90webpack%E3%80%91webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin \= <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>); <span class="comment">//配置路径</span></span><br><span class="line"><span class="keyword">const</span> PATH = &#123; <span class="comment">//path.jion 把当前文件的绝对路径与相对路径相结合生成新的路径</span></span><br><span class="line">    app:path.join(\_\_dirname,<span class="string">"src/index.js"</span>),</span><br><span class="line">    build:path.join(\_\_dirname,<span class="string">"dist"</span>)</span><br><span class="line">&#125; <span class="comment">//module 打包的配置项</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        app:PATH.app</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">"\[name\].js"</span>,</span><br><span class="line">        path:PATH.build</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="built_in">module</span>:&#123; <span class="comment">//test  匹配类型 通过loader进行合并</span></span><br><span class="line"> rules:\[</span><br><span class="line">           &#123;</span><br><span class="line">                test:<span class="regexp">/\\.(js|jsx)$/</span>,</span><br><span class="line">                use:&#123; <span class="comment">//打包js  一个打包的工具</span></span><br><span class="line">                    loader:<span class="string">"babel-loader"</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        presets:\[<span class="string">"@babel/env"</span>,<span class="string">"@babel/react"</span>\]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">               exclude:\_\_dirname+<span class="string">"node\_modules"</span> &#125;,&#123;</span><br><span class="line">               test:<span class="regexp">/\\.(css|scss)$/</span>,</span><br><span class="line">               loader:\[<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>,<span class="string">"sass-loader"</span>\]</span><br><span class="line">           &#125;</span><br><span class="line">       \]</span><br><span class="line">   &#125;, <span class="comment">//plugins  插件</span></span><br><span class="line"> plugins:\[ <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:<span class="string">"index.html"</span>,</span><br><span class="line">            filename:<span class="string">"index.html"</span> &#125;)</span><br><span class="line">   \]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>内蒙古之旅</title>
    <url>/2019/07/14/%E5%86%85%E8%92%99%E5%8F%A4%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h5 id="去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）"><a href="#去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）" class="headerlink" title="去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）"></a>去内蒙出差，觉得来一趟不容易，就一块去玩了一圈（天忒热，快中暑了）</h5><p><img src="http://cloud.asenper.cn//20200613191858.jpg" alt="仙沙岛"><br><img src="http://cloud.asenper.cn//20200613195203.jpg" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://cloud.asenper.cn//20200613195241.jpg" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://cloud.asenper.cn//20200613195316.jpg" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_120831.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_122822.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_123545.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_131239.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://common.msmk.tech/IMG_20190714_131239.jpg?imageslim" alt="内蒙古鄂尔多斯响沙湾"><br><img src="http://cloud.asenper.cn//20200613192909.jpg" alt="杂技表演"><br><img src="http://cloud.asenper.cn//20200613192717.jpg" alt="杂技表演"><br><img src="http://common.msmk.tech/IMG_20190713_184312.jpg?imageslim" alt="呼和浩特成吉思汗公园"><br><img src="http://common.msmk.tech/IMG_20190713_184902.jpg?imageslim" alt="呼和浩特成吉思汗公园"><br><img src="http://cloud.asenper.cn//20200613194650.jpg" alt="呼和浩特跑马场"><br><img src="http://common.msmk.tech/IMG_20190713_194229.jpg?imageslim" alt="呼和浩特跑马场"></p>
]]></content>
  </entry>
  <entry>
    <title>一次弄懂EventLoop</title>
    <url>/2020/06/22/%E4%B8%80%E6%AC%A1%E5%BC%84%E6%87%82EventLoop/</url>
    <content><![CDATA[<p>原文链接 <a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">https://juejin.im/post/5c3d8956e51d4511dc72c200</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p>
<h2 id="为啥要弄懂Event-Loop"><a href="#为啥要弄懂Event-Loop" class="headerlink" title="为啥要弄懂Event Loop"></a>为啥要弄懂Event Loop</h2><ul>
<li><p>是要增加自己技术的深度，也就是懂得<code>JavaScript</code>的运行机制。</p>
</li>
<li><p>现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变。</p>
</li>
<li><p>应对各大互联网公司的面试，懂其原理，题目任其发挥。</p>
</li>
</ul>
<h2 id="堆，栈、队列"><a href="#堆，栈、队列" class="headerlink" title="堆，栈、队列"></a>堆，栈、队列</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE3LzE2ODU5Yzk4NDgwNmM3OGQ?x-oss-process=image/format,png" alt=""></p>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p><strong>堆</strong>是一种数据结构，是利用完全二叉树维护的一组数据，<strong>堆</strong>分为两种，一种为最大<strong>堆</strong>，一种为<strong>最小堆</strong>，将根节点<strong>最大</strong>的<strong>堆</strong>叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点<strong>最小</strong>的<strong>堆</strong>叫做<strong>最小堆</strong>或<strong>小根堆</strong>。<br><strong>堆</strong>是<a href="https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html" target="_blank" rel="noopener"><strong>线性数据结构</strong></a>，相当于<strong>一维数组</strong>，有唯一后继。</p>
<p>如最大堆</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE3LzE2ODU5ZGJiNWI5YzdjYTE?x-oss-process=image/format,png" alt=""></p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p><strong>栈</strong>在计算机科学中是限定仅在<strong>表尾</strong>进行<strong>插入</strong>或<strong>删除</strong>操作的线性表。 <strong>栈</strong>是一种数据结构，它按照<strong>后进先出</strong>的原则存储数据，<strong>先进入</strong>的数据被压入<strong>栈底</strong>，<strong>最后的数据</strong>在<strong>栈顶</strong>，需要读数据的时候从<strong>栈顶</strong>开始<strong>弹出数据</strong>。<br><strong>栈</strong>是只能在<strong>某一端插入</strong>和<strong>删除</strong>的<strong>特殊线性表</strong>。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE3LzE2ODU5ZWQ0ZjYxNDMwNDM?x-oss-process=image/format,png" alt=""></p>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>特殊之处在于它只允许在表的前端（<code>front</code>）进行<strong>删除</strong>操作，而在表的后端（<code>rear</code>）进行<strong>插入</strong>操作，和<strong>栈</strong>一样，<strong>队列</strong>是一种操作受限制的线性表。<br>进行<strong>插入</strong>操作的端称为<strong>队尾</strong>，进行<strong>删除</strong>操作的端称为<strong>队头</strong>。 队列中没有元素时，称为<strong>空队列</strong>。</p>
<p><strong>队列</strong>的数据元素又称为<strong>队列元素</strong>。在队列中插入一个队列元素称为<strong>入队</strong>，从<strong>队列</strong>中<strong>删除</strong>一个队列元素称为<strong>出队</strong>。因为队列<strong>只允许</strong>在一端<strong>插入</strong>，在另一端<strong>删除</strong>，所以只有<strong>最早</strong>进入<strong>队列</strong>的元素<strong>才能最先从队列中</strong>删除，故队列又称为<strong>先进先出</strong>（<code>FIFO—first in first out</code>）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE3LzE2ODU5ZjJmNGY1ZGEyYTg?x-oss-process=image/format,png" alt=""></p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p>
<h3 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h3><ul>
<li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有IE10支持，具体可见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate" target="_blank" rel="noopener"><code>MDN</code></a>）、<code>I/O</code>、<code>UI Rendering</code>。</li>
</ul>
<h3 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h3><ul>
<li><code>Process.nextTick（Node独有）</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code>（具体使用方式查看<a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="noopener">这里</a>）</li>
</ul>
<h2 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h2><p><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<h3 id="JS调用栈"><a href="#JS调用栈" class="headerlink" title="JS调用栈"></a>JS调用栈</h3><p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p><code>Javascript</code>单线程任务被分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE4LzE2ODVmMDNkN2Y4ODc5MmI?x-oss-process=image/format,png" alt=""></p>
<p>任务队列<code>Task Queue</code>，即队列，是一种先进先出的一种数据结构。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE4LzE2ODVmMDM3ZDQ4ZGEwZGU?x-oss-process=image/format,png" alt=""></p>
<h3 id="事件循环的进程模型"><a href="#事件循环的进程模型" class="headerlink" title="事件循环的进程模型"></a>事件循环的进程模型</h3><ul>
<li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即<code>null</code>，则执行跳转到微任务（<code>MicroTask</code>）的执行步骤。</li>
<li>将事件循环中的任务设置为已选择任务。</li>
<li>执行任务。</li>
<li>将事件循环中当前运行任务设置为null。</li>
<li>将已经运行完成的任务从任务队列中删除。</li>
<li>microtasks步骤：进入microtask检查点。</li>
<li>更新界面渲染。</li>
<li>返回第一步。</li>
</ul>
<h3 id="执行进入microtask检查点时，用户代理会执行以下步骤"><a href="#执行进入microtask检查点时，用户代理会执行以下步骤" class="headerlink" title="执行进入microtask检查点时，用户代理会执行以下步骤"></a>执行进入microtask检查点时，用户代理会执行以下步骤</h3><ul>
<li>设置microtask检查点标志为true。</li>
<li>当事件循环<code>microtask</code>执行不为空时：选择一个最先进入的<code>microtask</code>队列的<code>microtask</code>，将事件循环的<code>microtask</code>设置为已选择的<code>microtask</code>，运行<code>microtask</code>，将已经执行完成的<code>microtask</code>为<code>null</code>，移出<code>microtask</code>中的<code>microtask</code>。</li>
<li>清理IndexDB事务</li>
<li>设置进入microtask检查点的标志为false。</li>
</ul>
<p>上述可能不太好理解，下图是我做的一张图片。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE4LzE2ODYwNzhjN2EyZjYzZTU?x-oss-process=image/format,png" alt=""></p>
<p>执行栈在执行完<strong>同步任务</strong>后，查看<strong>执行栈</strong>是否为空，如果执行栈为空，就会去检查<strong>微任务</strong>(<code>microTask</code>)队列是否为空，如果为空的话，就执行<code>Task</code>（宏任务），否则就一次性执行完所有微任务。<br>每次单个<strong>宏任务</strong>执行完毕后，检查<strong>微任务</strong>(<code>microTask</code>)队列是否为空，如果不为空的话，会按照<strong>先入先</strong>出的规则全部执行完<strong>微任务</strong>(<code>microTask</code>)后，设置<strong>微任务</strong>(<code>microTask</code>)队列为<code>null</code>，然后再执行<strong>宏任务</strong>，如此循环。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#39;promise1&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#39;script end&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先我们划分几个分类：</p>
<h3 id="第一次执行"><a href="#第一次执行" class="headerlink" title="第一次执行"></a>第一次执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tasks：run script、 setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：Promise then</span><br><span class="line"></span><br><span class="line">JS stack: script</span><br><span class="line">Log: script start、script end。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行同步代码，将宏任务（<code>Tasks</code>）和微任务(<code>Microtasks</code>)划分到各自队列中。</p>
<h3 id="第二次执行"><a href="#第二次执行" class="headerlink" title="第二次执行"></a>第二次执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tasks：run script、 setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：Promise2 then</span><br><span class="line"></span><br><span class="line">JS stack: Promise2 callback</span><br><span class="line">Log: script start、script end、promise1、promise2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行宏任务后，检测到微任务(<code>Microtasks</code>)队列中不为空，执行<code>Promise1</code>，执行完成<code>Promise1</code>后，调用<code>Promise2.then</code>，放入微任务(<code>Microtasks</code>)队列中，再执行<code>Promise2.then</code>。</p>
<h3 id="第三次执行"><a href="#第三次执行" class="headerlink" title="第三次执行"></a>第三次执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tasks：setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：</span><br><span class="line"></span><br><span class="line">JS stack: setTimeout callback</span><br><span class="line">Log: script start、script end、promise1、promise2、setTimeout</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当微任务(<code>Microtasks</code>)队列中为空时，执行宏任务（<code>Tasks</code>），执行<code>setTimeout callback</code>，打印日志。</p>
<h3 id="第四次执行"><a href="#第四次执行" class="headerlink" title="第四次执行"></a>第四次执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tasks：setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：</span><br><span class="line"></span><br><span class="line">JS stack:</span><br><span class="line">Log: script start、script end、promise1、promise2、setTimeout</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>清空<strong>Tasks</strong>队列和<code>JS stack</code>。</p>
<p>以上执行帧动画可以查看<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br>或许这张图也更好理解些。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE4LzE2ODYwYWU1YWQwMmY5OTM?x-oss-process=image/format,png" alt=""></p>
<h2 id="再举个例子"><a href="#再举个例子" class="headerlink" title="再举个例子"></a>再举个例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;script start&#39;)</span><br><span class="line"></span><br><span class="line">async function async1() &#123;</span><br><span class="line">  await async2()</span><br><span class="line">  console.log(&#39;async1 end&#39;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&#39;async2 end&#39;)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Promise&#39;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(function() &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function() &#123;</span><br><span class="line">    console.log(&#39;promise2&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#39;script end&#39;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里需要先理解<code>async/await</code>。</p>
<p><code>async/await</code> 在底层转换成了 <code>promise</code> 和 <code>then</code> 回调函数。<br>也就是说，这是 <code>promise</code> 的语法糖。<br>每次我们使用 <code>await</code>, 解释器都创建一个 <code>promise</code> 对象，然后把剩下的 <code>async</code> 函数中的操作放到 <code>then</code> 回调函数中。<br><code>async/await</code> 的实现，离不开 <code>Promise</code>。从字面意思来理解，<code>async</code> 是“异步”的简写，而 <code>await</code> 是 <code>async wait</code> 的简写可以认为是等待异步方法执行完成。</p>
<h3 id="关于73以下版本和73版本的区别"><a href="#关于73以下版本和73版本的区别" class="headerlink" title="关于73以下版本和73版本的区别"></a><strong>关于73以下版本和73版本的区别</strong></h3><ul>
<li>在老版本版本以下，先执行<code>promise1</code>和<code>promise2</code>，再执行<code>async1</code>。</li>
<li>在73版本，先执行<code>async1</code>再执行<code>promise1</code>和<code>promise2</code>。</li>
</ul>
<p><strong>主要原因是因为在谷歌(金丝雀)73版本中更改了规范，如下图所示：</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzIxLzE2ODZlYjI5YTZhMTk2NTg?x-oss-process=image/format,png" alt=""></p>
<ul>
<li>区别在于<code>RESOLVE(thenable)</code>和之间的区别<code>Promise.resolve(thenable)</code>。</li>
</ul>
<h3 id="在老版本中"><a href="#在老版本中" class="headerlink" title="在老版本中"></a><strong>在老版本中</strong></h3><ul>
<li>首先，传递给 <code>await</code> 的值被包裹在一个 <code>Promise</code> 中。然后，处理程序附加到这个包装的 <code>Promise</code>，以便在 <code>Promise</code> 变为 <code>fulfilled</code> 后恢复该函数，并且暂停执行异步函数，一旦 <code>promise</code> 变为 <code>fulfilled</code>，恢复异步函数的执行。</li>
<li>每个 <code>await</code> 引擎必须创建两个额外的 Promise（即使右侧已经是一个 <code>Promise</code>）并且它需要至少三个 <code>microtask</code> 队列 <code>ticks</code>（<code>tick</code>为系统的相对时间单位，也被称为系统的时基，来源于定时器的周期性中断（输出脉冲），一次中断表示一个<code>tick</code>，也被称做一个“时钟滴答”、时标。）。</li>
</ul>
<h3 id="引用贺老师知乎上的一个例子"><a href="#引用贺老师知乎上的一个例子" class="headerlink" title="引用贺老师知乎上的一个例子"></a><strong>引用贺老师知乎上的一个例子</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await p</span><br><span class="line">  console.log(&#39;ok&#39;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>简化理解为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  return RESOLVE(p).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;ok&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>RESOLVE(p)</code> 对于 <code>p</code> 为 <code>promise</code> 直接返回 <code>p</code> 的话，那么 <code>p</code>的 <code>then</code> 方法就会被马上调用，其回调就立即进入 <code>job</code> 队列。</li>
<li>而如果 <code>RESOLVE(p)</code> 严格按照标准，应该是产生一个新的 <code>promise</code>，尽管该 <code>promise</code>确定会 <code>resolve</code> 为 <code>p</code>，但这个过程本身是异步的，也就是现在进入 <code>job</code> 队列的是新 <code>promise</code> 的 <code>resolve</code>过程，所以该 <code>promise</code> 的 <code>then</code> 不会被立即调用，而要等到当前 <code>job</code> 队列执行到前述 <code>resolve</code> 过程才会被调用，然后其回调（也就是继续 <code>await</code> 之后的语句）才加入 <code>job</code> 队列，所以时序上就晚了。</li>
</ul>
<h3 id="谷歌（金丝雀）73版本中"><a href="#谷歌（金丝雀）73版本中" class="headerlink" title="谷歌（金丝雀）73版本中"></a><strong>谷歌（金丝雀）73版本中</strong></h3><ul>
<li>使用对<code>PromiseResolve</code>的调用来更改<code>await</code>的语义，以减少在公共<code>awaitPromise</code>情况下的转换次数。</li>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
</ul>
<h3 id="详细过程："><a href="#详细过程：" class="headerlink" title="详细过程："></a><strong>详细过程：</strong></h3><p><strong>73以下版本</strong></p>
<ul>
<li>首先，打印<code>script start</code>，调用<code>async1()</code>时，返回一个<code>Promise</code>，所以打印出来<code>async2 end</code>。</li>
<li>每个 <code>await</code>，会新产生一个<code>promise</code>,但这个过程本身是异步的，所以该<code>await</code>后面不会立即调用。</li>
<li>继续执行同步代码，打印<code>Promise</code>和<code>script end</code>，将<code>then</code>函数放入<strong>微任务</strong>队列中等待执行。</li>
<li>同步执行完成之后，检查<strong>微任务</strong>队列是否为<code>null</code>，然后按照先入先出规则，依次执行。</li>
<li>然后先执行打印<code>promise1</code>,此时<code>then</code>的回调函数返回<code>undefinde</code>，此时又有<code>then</code>的链式调用，又放入<strong>微任务</strong>队列中，再次打印<code>promise2</code>。</li>
<li>再回到<code>await</code>的位置执行返回的 <code>Promise</code> 的 <code>resolve</code> 函数，这又会把 <code>resolve</code> 丢到微任务队列中，打印<code>async1 end</code>。</li>
<li>当<strong>微任务</strong>队列为空时，执行宏任务,打印<code>setTimeout</code>。</li>
</ul>
<p><strong>谷歌（金丝雀73版本）</strong></p>
<ul>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
<li>引擎不再需要为 <code>await</code> 创造 <code>throwaway Promise</code> - 在绝大部分时间。</li>
<li>现在 <code>promise</code> 指向了同一个 <code>Promise</code>，所以这个步骤什么也不需要做。然后引擎继续像以前一样，创建 <code>throwaway Promise</code>，安排 <code>PromiseReactionJob</code> 在 <code>microtask</code> 队列的下一个 <code>tick</code> 上恢复异步函数，暂停执行该函数，然后返回给调用者。</li>
</ul>
<p>具体详情查看（<a href="https://v8.js.cn/blog/fast-async/" target="_blank" rel="noopener">这里</a>）。</p>
<h2 id="NodeJS的Event-Loop"><a href="#NodeJS的Event-Loop" class="headerlink" title="NodeJS的Event Loop"></a>NodeJS的Event Loop</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE4LzE2ODYwZjM1ZDNhM2U1MGQ?x-oss-process=image/format,png" alt=""></p>
<p><code>Node</code>中的<code>Event Loop</code>是基于<code>libuv</code>实现的，而<code>libuv</code>是 <code>Node</code> 的新跨平台抽象层，libuv使用异步，事件驱动的编程方式，核心是提供<code>i/o</code>的事件循环和异步回调。libuv的<code>API</code>包含有时间，非阻塞的网络，异步文件操作，子进程等等。 <code>Event Loop</code>就是在<code>libuv</code>中实现的。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE4LzE2ODYwZjhmOGY3ZjA1M2Q?x-oss-process=image/format,png" alt=""></p>
<h3 id="Node的Event-loop一共分为6个阶段，每个细节具体如下"><a href="#Node的Event-loop一共分为6个阶段，每个细节具体如下" class="headerlink" title="Node的Event loop一共分为6个阶段，每个细节具体如下"></a><code>Node</code>的<code>Event loop</code>一共分为6个阶段，每个细节具体如下</h3><ul>
<li><code>timers</code>: 执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>。</li>
<li><code>pending callback</code>: 上一轮循环中少数的<code>callback</code>会放在这一阶段执行。</li>
<li><code>idle, prepare</code>: 仅在内部使用。</li>
<li><code>poll</code>: 最重要的阶段，执行<code>pending callback</code>，在适当的情况下回阻塞在这个阶段。</li>
<li><code>check</code>: 执行<code>setImmediate</code>(<code>setImmediate()</code>是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行<code>setImmediate</code>指定的回调函数)的<code>callback</code>。</li>
<li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，例如<code>socket.on(&#39;close&#39;[,fn])</code>或者<code>http.server.on(&#39;close, fn)</code>。</li>
</ul>
<p>具体细节如下：</p>
<h3 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h3><p>执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于<code>system</code>的调度可能会延时，达不到预期时间。<br>以下是官网文档解释的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation(callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; Assume this takes 95ms to complete</span><br><span class="line">  fs.readFile(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeoutScheduled &#x3D; Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  const delay &#x3D; Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  console.log(&#96;$&#123;delay&#125;ms have passed since I was scheduled&#96;);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; do someAsyncOperation which takes 95 ms to complete</span><br><span class="line">someAsyncOperation(() &#x3D;&gt; &#123;</span><br><span class="line">  const startCallback &#x3D; Date.now();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; do something that will take 10ms...</span><br><span class="line">  while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当进入事件循环时，它有一个空队列（<code>fs.readFile()</code>尚未完成），因此定时器将等待剩余毫秒数，当到达95ms时，<code>fs.readFile()</code>完成读取文件并且其完成需要10毫秒的回调被添加到轮询队列并执行。<br>当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的<strong>阈值</strong>，然后回到<strong>timers阶段</strong>以执行定时器的回调。</p>
<p>在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为105毫秒。</p>
<p><strong>以下是我测试时间：</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE5LzE2ODY0YjgxNzdjMjVlYWY?x-oss-process=image/format,png" alt=""></p>
<h3 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h3><p>此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果<code>TCP socket ECONNREFUSED</code>在尝试connect时receives，则某些* nix系统希望等待报告错误。 这将在<code>pending callbacks</code>阶段执行。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>该poll阶段有两个主要功能：</strong></p>
<ul>
<li>执行<code>I/O</code>回调。</li>
<li>处理轮询队列中的事件。</li>
</ul>
<p><strong>当事件循环进入<code>poll</code>阶段并且在<code>timers</code>中没有可以执行定时器时，将发生以下两种情况之一</strong></p>
<ul>
<li>如果<code>poll</code>队列不为空，则事件循环将遍历其同步执行它们的<code>callback</code>队列，直到队列为空，或者达到<code>system-dependent</code>（系统相关限制）。</li>
</ul>
<p><strong>如果<code>poll</code>队列为空，则会发生以下两种情况之一</strong></p>
<ul>
<li><p>如果有<code>setImmediate()</code>回调需要执行，则会立即停止执行<code>poll</code>阶段并进入执行<code>check</code>阶段以执行回调。</p>
</li>
<li><p>如果没有<code>setImmediate()</code>回到需要执行，poll阶段将等待<code>callback</code>被添加到队列中，然后立即执行。</p>
</li>
</ul>
<p><strong>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</strong></p>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p><strong>此阶段允许人员在poll阶段完成后立即执行回调。</strong><br>如果<code>poll</code>阶段闲置并且<code>script</code>已排队<code>setImmediate()</code>，则事件循环到达check阶段执行而不是继续等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用<code>libuv API</code>来调度在<code>poll</code>阶段完成后执行的回调。</p>
<p>通常，当代码被执行时，事件循环最终将达到<code>poll</code>阶段，它将等待传入连接，请求等。<br>但是，如果已经调度了回调<code>setImmediate()</code>，并且轮询阶段变为空闲，则它将结束并且到达<code>check</code>阶段，而不是等待<code>poll</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;start&#39;)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;timer1&#39;)</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;timer2&#39;)</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&#39;promise2&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#39;promise3&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;end&#39;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果<code>node</code>版本为<code>v11.x</code>， 其结果与浏览器一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>具体详情可以查看《<a href="https://juejin.im/post/5c3e8d90f265da614274218a" target="_blank" rel="noopener">又被node的eventloop坑了，这次是node的锅</a>》。</p>
<p>如果v10版本上述结果存在两种情况：</p>
<ul>
<li>如果time2定时器已经在执行队列中了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>如果time2定时器没有在执行对列中，执行结果为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>具体情况可以参考<code>poll</code>阶段的两种情况。</p>
<p>从下图可能更好理解：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xLzE5LzE2ODY1MzBiY2Q0ZTQ1NmE?x-oss-process=image/format,png" alt=""></p>
<h2 id="setImmediate-的setTimeout-的区别"><a href="#setImmediate-的setTimeout-的区别" class="headerlink" title="setImmediate() 的setTimeout()的区别"></a>setImmediate() 的setTimeout()的区别</h2><p><strong><code>setImmediate</code>和<code>setTimeout()</code>是相似的，但根据它们被调用的时间以不同的方式表现。</strong></p>
<ul>
<li><code>setImmediate()</code>设计用于在当前<code>poll</code>阶段完成后check阶段执行脚本 。</li>
<li><code>setTimeout()</code> 安排在经过最小（ms）后运行的脚本，在<code>timers</code>阶段执行。</li>
</ul>
<h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;timeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;immediate&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。</strong></p>
<p><strong>其结果也不一致</strong></p>
<p><strong>如果在<code>I / O</code>周期内移动两个调用，则始终首先执行立即回调：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;timeout&#39;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;immediate&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其结果可以确定一定是<code>immediate =&gt; timeout</code>。<br>主要原因是在<code>I/O阶段</code>读取文件后，事件循环会先进入<code>poll</code>阶段，发现有<code>setImmediate</code>需要执行，会立即进入<code>check</code>阶段执行<code>setImmediate</code>的回调。</p>
<p>然后再进入<code>timers</code>阶段，执行<code>setTimeout</code>，打印<code>timeout</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h2><p><strong><code>process.nextTick()</code>虽然它是异步API的一部分，但未在图中显示。这是因为<code>process.nextTick()</code>从技术上讲，它不是事件循环的一部分。</strong></p>
<ul>
<li><code>process.nextTick()</code>方法将 <code>callback</code> 添加到<code>next tick</code>队列。 一旦当前事件轮询队列的任务全部完成，在<code>next tick</code>队列中的所有<code>callbacks</code>会被依次调用。</li>
</ul>
<p><strong>换种理解方式：</strong></p>
<ul>
<li>当每个阶段完成后，如果存在 <code>nextTick</code> 队列，就会清空队列中的所有回调函数，并且优先于其他 <code>microtask</code> 执行。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setImmediate&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;bar&#39;, bar); &#x2F;&#x2F; 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在NodeV10中上述代码执行可能有两种答案，一种为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar 1</span><br><span class="line">setTimeout</span><br><span class="line">setImmediate</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>另一种为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar 1</span><br><span class="line">setImmediate</span><br><span class="line">setTimeout</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>无论哪种，始终都是先执行<code>process.nextTick(callback)</code>，打印<code>bar 1</code>。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢@Dante_Hu提出这个问题<code>await</code>的问题，文章已经修正。 修改了node端执行结果。V10和V11的区别。</p>
<h3 id="关于await问题参考了以下文章："><a href="#关于await问题参考了以下文章：" class="headerlink" title="关于await问题参考了以下文章："></a><strong>关于await问题参考了以下文章：</strong></h3><p>《<a href="https://github.com/xianshenglu/blog/issues/60" target="_blank" rel="noopener">promise, async, await, execution order</a>》<br>《<a href="https://github.com/tc39/ecma262/pull/1250" target="_blank" rel="noopener">Normative: Reduce the number of ticks in async/await</a>》<br>《<a href="https://www.zhihu.com/question/268007969" target="_blank" rel="noopener">async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？</a>》<br>《<a href="https://v8.js.cn/blog/fast-async/" target="_blank" rel="noopener">更快的异步函数和 Promise</a>》</p>
<h3 id="其他内容参考了"><a href="#其他内容参考了" class="headerlink" title="其他内容参考了"></a>其他内容参考了</h3><p>《<a href="https://segmentfault.com/a/1190000015559210" target="_blank" rel="noopener">JS浏览器事件循环机制</a>》<br>《<a href="https://segmentfault.com/a/1190000010622146" target="_blank" rel="noopener">什么是浏览器的事件循环（Event Loop）？</a>》<br>《<a href="https://segmentfault.com/a/1190000013861128" target="_blank" rel="noopener">一篇文章教会你Event loop——浏览器和Node</a>》<br>《<a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882" target="_blank" rel="noopener">不要混淆nodejs和浏览器中的event loop</a>》<br>《<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a>》<br>《<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a>》<br>《<a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5be04a8e6fb9a04a072fd2cd#heading-3" target="_blank" rel="noopener">前端面试之道</a>》<br>《<a href="https://www.jianshu.com/p/8e0ad01c41dc" target="_blank" rel="noopener">Node.js介绍5-libuv的基本概念</a>》<br>《<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a>》<br>《<a href="http://nodejs.cn/" target="_blank" rel="noopener">node官网</a>》</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔webhooks实现hexo自动部署</title>
    <url>/2019/05/10/%E5%AE%9D%E5%A1%94hexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="webhook自动部署"><a href="#webhook自动部署" class="headerlink" title="webhook自动部署"></a>webhook自动部署</h3><p>首先确保你的服务器已经安装了宝塔，安装webhook插件 ，添加hook 输入名称及一下脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line"><span class="comment"># 输出当前时间</span></span><br><span class="line">date --date=<span class="string">'0 days ago'</span> <span class="string">"+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Start"</span></span><br><span class="line"><span class="comment"># 判断宝塔WebHook参数是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$1</span>"</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"param参数错误"</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"End"</span></span><br><span class="line">          <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># git项目路径</span></span><br><span class="line">gitPath=<span class="string">"/www/wwwroot/<span class="variable">$1</span>"</span></span><br><span class="line"><span class="comment"># git 网址</span></span><br><span class="line">gitHttp=<span class="string">"http://git.xxxxx.com/<span class="variable">$1</span>.git"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Web站点路径：<span class="variable">$gitPath</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断项目路径是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$gitPath</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$gitPath</span></span><br><span class="line">        <span class="comment"># 判断是否存在git目录</span></span><br><span class="line">        <span class="keyword">if</span> [ ! -d <span class="string">".git"</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"在该目录下克隆 git"</span></span><br><span class="line">                git <span class="built_in">clone</span> <span class="variable">$gitHttp</span> gittemp</span><br><span class="line">                mv gittemp/.git .</span><br><span class="line">                rm -rf gittemp</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="comment"># 拉取最新的项目文件</span></span><br><span class="line">        git reset --hard origin/master</span><br><span class="line">        git pull</span><br><span class="line">        <span class="comment"># 设置目录权限</span></span><br><span class="line">        chown -R www:www <span class="variable">$gitPath</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"End"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"该项目路径不存在"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"End"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>然后会生成 一个密钥 和 相关的链接</p>
<h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><p><img src="http://cloud.asenper.cn//20200613184752.png" alt="image-20200613184750432"></p>
<p>如图,添加webhooks,Payload URL为上一步生成的链接，Secret为密钥<br>就这么简单</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>动态图演示Promises&amp;Async、Await 的过程</title>
    <url>/2020/05/27/%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BAPromises&amp;Async%E3%80%81Await%20%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>原文： <a href="https://www.toutiao.com/i6830934809552880135" target="_blank" rel="noopener">https://www.toutiao.com/i6830934809552880135</a><br>非常好的一篇文章</p>
<h2 id="动态图演示-Promises-amp-Async-Await-的过程"><a href="#动态图演示-Promises-amp-Async-Await-的过程" class="headerlink" title="动态图演示 Promises &amp; Async/Await 的过程"></a>动态图演示 Promises &amp; Async/Await 的过程</h2><p><img src="http://p1.pstatp.com/large/pgc-image/4c2c3b8dfca5459892f256bba6a37ee8" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<blockquote>
<p>原文地址：<br><a href="https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke原文作者：Lydia" target="_blank" rel="noopener">https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke原文作者：Lydia</a> Hallie</p>
</blockquote>
<h2 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h2><p>你是否运行过不按你预期运行的 js 代码 ？</p>
<p>比如：某个函数被随机的、不可预测时间的执行了，或者被延迟执行了。</p>
<p>这时，你需要从 ES6 中引入的一个非常酷的新特性: Promise 来处理你的问题。</p>
<p>为了深入理解 Promise ，我在某个不眠之夜，做了一些动画来演示 Promise 的运行，我多年来的好奇心终于得到实现。</p>
<p>对于 Promise ，您为什么要使用它，它在底层是如何工作的，以及我们如何以最现代的方式编写它呢？</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在书写 JavaScript 的时候，我们经常不得不去处理一些依赖于其它任务的任务！</p>
<p>比如：我们想要得到一个图片，对其进行压缩，应用一个滤镜，然后保存它 。</p>
<p>首先，先用 getImage 函数要得到我们想要编辑的图片。</p>
<p>一旦图片被成功加载，把这个图片值传到一个 ocmpressImage 函数中。</p>
<p>当图片已经被成功地重新调整大小后，在 applyFilter 函数中为图片应用一个滤镜。</p>
<p>在图片被压缩和添加滤镜后，保存图片并且打印成功的日志！</p>
<p>最后，代码很简单如图：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/0e90e4f9fcd544bb81e17ec9bfc33ed3" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>注意到了吗？尽管以上代码也能得到我们想要的结果，但是完成的过程并不是友好。</p>
<p>使用了大量嵌套的回调函数，这使我们的代码阅读起来特别困难。</p>
<p>因为写了许多嵌套的回调函数，这些回调函数又依赖于前一个回调函数，这通常被称为 回调地狱。</p>
<p>幸运的，ES6 中的 Promise 的能很好的处理这种情况！</p>
<p>让我们看看 promise 是什么，以及它是如何在类似于上述的情况下帮助我们的。</p>
<h2 id="Promise语法"><a href="#Promise语法" class="headerlink" title="Promise语法"></a>Promise语法</h2><p>ES6引入了Promise。在许多教程中，你可能会读到这样的内容：</p>
<blockquote>
<p>Promise 是一个值的占位符，这个值在未来的某个时间要么 resolve 要么 reject 。</p>
</blockquote>
<p>对于我来说，这样的解释从没有让事情变得更清楚。</p>
<p>事实上，它只是让我感觉 Promise 是一个奇怪的、模糊的、不可预测的一段魔法。</p>
<p>接下来让我们看看 promise 真正是什么？</p>
<p>我们可以使用一个接收一个回调函数的 Promise 构造器创建一个 promise。</p>
<p>好酷，让我们尝试一下！</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/ffd3b44188854012b81afb73f44cf21c" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>等等，刚刚得到的返回值是什么？</p>
<p>Promise 是一个对象，它包含一个状态 PromiseStatus 和一个值 PromiseValue。</p>
<p>在上面的例子中，你可以看到 PromiseStatus 的值是 pending, PromiseValue 的值是 undefined。</p>
<p>不过 - 你将永远不会与这个对象进行交互，你甚至不能访问 PromiseStatus 和 PromiseValue 这两个属性！</p>
<p>然而，在使用 Promise 的时候，这俩个属性的值是非常重要的。</p>
<hr>
<p>PromiseStatus 的值，也就是 Promise 的状态，可以是以下三个值之一：</p>
<ul>
<li>✅ fulfilled: promise 已经被 resolved。一切都很好，在 promise 内部没有错误发生。</li>
<li>❌ rejected: promise 已经被 rejected。哎呦，某些事情出错了。</li>
<li>⏳ pending: promise 暂时还没有被解决也没有被拒绝，仍然处于 pending 状态</li>
</ul>
<p>好吧，这一切听起来很棒，但是什么时候 promise 的状态是 pending、fulfilled 或 rejected 呢? 为什么这个状态很重要呢？</p>
<p>在上面的例子中，我们只是为 Promise 构造器传递了一个简单的回调函数 () =&gt; {} 。</p>
<p>然而，这个回调函数实际上接受两个参数。</p>
<ul>
<li>第一个参数的值经常被叫做 resolve 或 res，它是一个函数，在 Promise 应该解决 resolve 的时候会被调用。</li>
<li>第二个参数的值经常被叫做 reject 或 rej，它也是一个函数，在 Promise 出现一些错误应该被拒绝 reject 的时候被调用。</li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/493f4c5a604848e5a7639974bc1c4724" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>让我们尝试看看当我们调用 resolve 或 reject 方法时得到的日志。</p>
<p>在我的例子中，把 resolve 方法叫做 res，把 reject 方法叫做 rej。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/5dcdd48f0dea49e2926ec6ea1a037210" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>太好了！我们终于知道如何摆脱 pending 状态和 undefined 值了！</p>
<ul>
<li>当我们调用 resolve 方法时，promise 的状态是 fulfilled。</li>
<li>当我们调用 reject 方法时，promise 的状态是 rejected。</li>
</ul>
<blockquote>
<p>有趣的是，我让（Jake Archibald）校对了这篇文章，他实际上指出 Chrome 中存在一个错误，该错误当前将状态显示为 “ fulfilled” 而不是 “ resolved”。感谢 Mathias Bynens，它现已在Canary 中修复！</p>
</blockquote>
<p>好了，现在我们知道如何更好控制那个模糊的 Promise 对象。但是他被用来做什么呢？</p>
<p>在前面的介绍章节，我展示了一个获得图片、压缩图片、为图片应用过滤器并保存它的例子！最终，这变成了一个混乱的嵌套回调。</p>
<p>幸运的，Promise 可以帮助我们解决这个问题！</p>
<p>首先，让我们重写整个代码块，以便每个函数返回一个 Promise 来代替之前的函数。</p>
<p>如果图片被加载完成并且一切正常，让我们用加载完的图片解决 (resolve)promise。</p>
<p>否则，如果在加载文件时某个地方有一个错误，我们将会用发生的错误拒绝 (reject)promise 。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/d0d5b7a8adde4b729330252d5fc02ddf" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>让我们看下当我们在终端运行这段代码时会发生什么？</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/6845e3935ddc489cbcf652d752733baa" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>非常酷！就像我们所期望的一样，promise 得到了解析数据后的值。</p>
<p>但是现在呢？我们不关心整个 promise 对象，我们只关心数据的值！幸运的，有内置的方法来得到 promise 的值。</p>
<p>对于一个 promise，我们可以使用它上面的 3 个方法：</p>
<ul>
<li>.then(): 在一个 promise 被 resolved 后调用</li>
<li>.catch(): 在一个 promise 被 rejected 后被调用</li>
<li>.finally(): 不论 promise 是被 resolved 还是 reject 总是调用</li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/7f7fd9b7255c4dac91360c92ce9561f8" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>.then 方法接收传递给 resolve 方法的值。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/76074b7d96f8434c93819e792b765dcc" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>.catch 方法接收传递给 rejected 方法的值。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/1c62ef30bf5e4f5f9105a3f5c6a91b73" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>最终，我们拥有了 promise 被解决后 (resolved) 的值，并不需要整个 promise 对象！</p>
<p>现在我们可以用这个值做任何我们想做的事。</p>
<hr>
<p>顺便提醒一下，当你知道一个 promise 总是 resolve 或者总是 reject 的时候，你可以写 Promise.resolve 或 Promise.reject，传入你想要 reject 或 resolve 的 promise 的值。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/599fa9087742482e82e38fb87b79171d" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>在下边的例子中你将会经常看到这个语法。</p>
<p>在 getImage 的例子中，为了运行它们，我们最终不得不嵌套多个回调。幸运的，.then 处理器可以帮助我们完成这件事！</p>
<p>.then 它自己的执行结果是一个 promise。这意味着我们可以链接任意数量的 .then：前一个 then 回调的结果将会作为参数传递给下一个 then 回调！</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/b46032238abe4bafa65f47e64f447d21" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>在 getImage 示例中，为了传递被处理的图片到下一个函数，我们可以链接多个 then 回调。</p>
<p>相比于之前最终得到许多嵌套回调，现在我们得到了整洁的 then 链。</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/059337833e664979abe988e7f2e33f5a" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>完美！这个语法看起来已经比之前的嵌套回调好多了。</p>
<h2 id="宏任务和微任务-macrotask-and-microtask"><a href="#宏任务和微任务-macrotask-and-microtask" class="headerlink" title="宏任务和微任务(macrotask and microtask)"></a>宏任务和微任务(macrotask and microtask)</h2><p>我们知道了一些如何创建 promise 以及如何提取出 promise 的值的方法。</p>
<p>让我们为脚本添加一些更多的代码并且再次运行它：</p>
<p><img src="http://p9.pstatp.com/large/pgc-image/aa9ea30928944273b27b282bce207139" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>等下，发生了什么？！</p>
<p>首先，Start! 被输出。</p>
<p>好的，我们已经看到了那一个即将到来的消息：console.log(‘Start!’) 在最前一行输出！</p>
<p>然而，第二个被打印的值是 End!，并不是 promise 被解决的值！只有在 End! 被打印之后，promise 的值才会被打印。</p>
<p>这里发生了什么？</p>
<p>我们最终看到了 promise 真正的力量！ 尽管 JavaScript 是单线程的，我们可以使用 Promise 添加异步任务！</p>
<p>等等，我们之前没见过这种情况吗？</p>
<p>在 JavaScript Event Loop 中，我们不是也可以使用浏览器原生的方法如 setTimeout 创建某类异步行为吗？</p>
<p>是的！然而，在事件循环内部，实际上有 2 种类型的队列：宏任务(macro)队列 (或者只是叫做 任务队列 )和 微任务队列。</p>
<p>(宏)任务队列用于 宏任务，微任务队列用于 微任务。</p>
<p>那么什么是宏任务，什么是微任务呢？</p>
<p>尽管他们比我在这里介绍的要多一些，但是最常用的已经被展示在下面的表格中！</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">(Macro)task:</td>
<td align="center">setTimeout</td>
<td align="center">setInterval</td>
<td align="center">setImmediate</td>
</tr>
<tr>
<td align="center">Microtask:</td>
<td align="center">process.nextTick</td>
<td align="center">Promise callback</td>
<td align="center">queueMicrotask</td>
</tr>
</tbody></table>
<p>我们看到 Promise 在微任务列表中！ 当一个 Promise 解决 (resolve) 并且调用它的 then()、catch() 或 finally() 方法的时候，这些方法里的回调函数被添加到微任务队列！</p>
<p>这意味着 then()，chatch() 或 finally() 方法内的回调函数不是立即被执行，本质上是为我们的 JavaScript 代码添加了一些异步行为！</p>
<p>那么什么时候执行 then()，catch()，或 finally() 内的回调呢？</p>
<p>事件循环给与任务不同的优先级：</p>
<ol>
<li>当前在调用栈 (call stack) 内的所有函数会被执行。当它们返回值的时候，会被从栈内弹出。</li>
<li>当调用栈是空的时，所有排队的微任务会一个接一个从微任务任务队列中弹出进入调用栈中，然后在调用栈中被执行！(微任务自己也能返回一个新的微任务，有效地创建无限的微任务循环 )</li>
<li>如果调用栈和微任务队列都是空的，事件循环会检查宏任务队列里是否还有任务。如果宏任务中还有任务，会从宏任务队列中弹出进入调用栈，被执行后会从调用栈中弹出！</li>
</ol>
<p>让我们快速地看一个简单的例子：</p>
<ul>
<li>Task1: 立即被添加到调用栈中的函数，比如在我们的代码中立即调用它。</li>
<li>Task2，Task3，Task4: 微任务，比如 promise 中 then 方法里的回调，或者用 queueMicrotask 添加的一个任务。</li>
<li>Task5，Task6: 宏任务，比如 setTimeout 或者 setImmediate 里的回调</li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/992a19061f1d48268bb7c571ab205858" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>首先，Task1 返回一个值并且从调用栈中弹出。然后，JavaScript 引擎检查微任务队列中排队的任务。一旦微任务中所有的任务被放入调用栈并且最终被弹出，JavaScript 引擎会检查宏任务队列中的任务，将他们弹入调用栈中并且在它们返回值的时候把它们弹出调用栈。</p>
<p>图中足够粉色的盒子是不同的任务，让我们用一些真实的代码来使用它！</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/c15f982cbd5748138b20aec7c7ac3cd8" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>在这段代码中，我们有宏任务 setTimeout 和 微任务 promise 的 then 回调。</p>
<p>一旦 JavaScript 引擎到达 setTimeout 函数所在的那行就会涉及到事件循环。</p>
<p>让我们一步一步地运行这段代码，看看会得到什么样的日志！</p>
<blockquote>
<p>快速提一下：在下边的例子中，我正在展示的像 console.log，setTimeout 和 Promise.resolve 等方法正在被添加到调用栈中。它们是内部的方法实际上没有出现在堆栈痕迹中，因此如果你正在使用调试器，不用担心，你不会在任何地方见到它们。它只是在没有添加一堆样本文件代码的情况下使这个概念解释起来更加简单。</p>
</blockquote>
<p>在第一行，JavaScript 引擎遇到了 console.log() 方法，它被添加到调用栈，之后它在控制台输出值 Start!。console.log 函数从调用栈内弹出，之后 JavaScript 引擎继续执行代码。</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/e4f19d57e9c54245af253a0029089217" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>JavaScript 引擎遇到了 setTimeout 方法，他被弹入调用栈中。setTimeout 是浏览器的原生方法：它的回调函数 (() =&gt; console.log(‘In timeout’)) 将会被添加到 Web API，直到计时器完成计时。尽管我们为计时器提供的值是 0，在它被添加到宏任务队列 (setTimeout 是一个宏任务) 之后回调还是会被首先推入 Web API。</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/50ac03a0030943549da8d31136f99dfb" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>JavaScript 引擎遇到了 Promise.resolve 方法。Promise.resolve 被添加到调用栈。在 Promise 解决 (resolve) 值之后，它的 then 中的回调函数被添加到微任务队列。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/0a0926672a864adeb8d9576bd411a5c5" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>JavaScript 引擎看到调用栈现在是空的。由于调用栈是空的，它将会去检查在微任务队列中是否有在排队的任务！是的，有任务在排队，promise 的 then 中的回调函数正在等待轮到它！它被弹入调用栈，之后它输出了 promise 被解决后( resolved )的值: 在这个例子中的字符串 Promise!。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/becc3f5d0de0435db7bb5d10459d4952" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>JavaScript 引擎看到调用栈是空的，因此，如果任务在排队的话，它将会再次去检查微任务队列。此时，微任务队列完全是空的。</p>
<p>到了去检查宏任务队列的时候了：setTimeout 回调仍然在那里等待！setTimeout 被弹入调用栈。回调函数返回 console.log 方法，输出了字符串 In timeout!。setTimeout 回调从调用栈中弹出。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/cc7ac61662004a7884def33c9aa12f03" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>终于，所有的事情完成了! 看起来我们之前看到的输出最终并不是那么出乎意料。</p>
<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>ES7 引入了一个新的在 JavaScript 中添加异步行为的方式并且使 promise 用起来更加简单！随着 async 和 await 关键字的引入，我们能够创建一个隐式的返回一个 promise 的 async 函数。但是，我们该怎么做呢？</p>
<p>之前，我们看到不管是通过输入 new Promise(() =&gt; {})，Promise.resolve 或 Promise.reject，我们都可以显式的使用 Promise 对象创建 promise。</p>
<p>我们现在能够创建隐式地返回一个对象的异步函数，而不是显式地使用 Promise 对象！这意味着我们不再需要写任何 Promise 对象了。</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/be4deb2f1f2b45b1b300975a3209f831" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>尽管 async 函数隐式的返回 promise 是一个非常棒的事实，但是在使用 await 关键字的时候才能看到 async 函数的真正力量。当我们等待 await 后的值返回一个 resolved 的 promise 时，通过 await 关键字，我们可以暂停异步函数。如果我们想要得到这个 resolved 的 promise 的值，就像我们之前用 then 回调那样，我们可以为被 await 的 promise 的值赋值为变量！</p>
<p>这样，我们就可以暂停一个异步函数吗？很好，但这到底是什么意思？</p>
<p>当我们运行下面的代码块时让我们看下发生了什么：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/93b4af8b508c45ba8e34576fe50937f9" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>额，这里发生了什么呢？</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/d7179d56073c4dee97a0e4080e5f20db" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>首先，JavaScript 引擎遇到了 console.log。它被弹入到调用栈中，这之后 Before function! 被输出。</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/1654e0ed40ff441087f7c8e08eab8800" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>然后，我们调用了异步函数myFunc()，这之后myFunc函数体运行。函数主体内的最开始一行，我们调用了另一个console.log，这次传入的是字符串In function!。console.log被添加到调用栈中，输出值，然后从栈内弹出。</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/8d5e085171cf4ef293c93cdb5c8a6613" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>函数体继续执行，将我们带到第二行。最终，我们看到一个await关键字！</p>
<p>最先发生的事是被等待的值执行：在这个例子中是函数one。它被弹入调用栈，并且最终返回一个解决状态的promise。一旦Promise被解决并且one返回一个值，JavaScript遇到了await关键字。</p>
<p>当遇到await关键字的时候，异步函数被暂停。函数体的执行被暂停，async函数中剩余的代码会在微任务中运行而不是一个常规任务！</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/534a2540a8fa45d19ea7a18bc26ddac6" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>现在，因为遇到了await关键字，异步函数myFunc被暂停，JavaScript引擎跳出异步函数，并且在异步函数被调用的执行上下文中继续执行代码：在这个例子中是全局执行上下文！ ‍♀️</p>
<p><img src="http://p9.pstatp.com/large/pgc-image/4b1bcd22d178472d93bd7dda4504e1e0" alt="动态图演示 Promises &amp; Async/Await 的过程"></p>
<p>最终，没有更多的任务在全局执行上下文中运行！事件循环检查看看是否有任何的微任务在排队：是的，有！在解决了one的值以后，异步函数myFunc开始排队。myFunc被弹入调用栈中，在它之前中断的地方继续运行。</p>
<p>变量res最终获得了它的值，也就是one返回的promise被解决的值！我们用res的值(在这个例子中是字符串One!)调用console.log。One!被打印到控制台并且console.log从调用栈弹出。</p>
<p>最终，所有的事情都完成了！你注意到async函数相比于promise的then有什么不同吗？await关键字暂停了async函数，然而如果我们使用then的话，Promise的主体将会继续被执行！</p>
<p>嗯，这是相当多的信息！ 当使用Promise的时候，如果你仍然感觉有一点不知所措，完全不用担心。我个人认为，当使用异步JavaScript的时候，只是需要经验去注意模式之后便会感到自信。</p>
<p>当使用异步JavaScript的时候，我希望你可能遇到的“无法预料的”或“不可预测的”行为现在变得更有意义！</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序点击多次navigator跳转无反应</title>
    <url>/2020/05/27/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%82%B9%E5%87%BB%E5%A4%9A%E6%AC%A1navigator%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%8F%8D%E5%BA%94/</url>
    <content><![CDATA[<p><code>navigator</code>组件<code>open-type</code>属性默认值为<code>navigate</code></p>
<p>而<code>navigate</code>对应<code>navigateTo</code>方法，可以看到文档中对<code>navigateTo</code>的说明：</p>
<p>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈<strong>最多十层</strong>。</p>
<p><strong>将 <code>open-type</code>属性值设为<code>redirect</code>即可</strong></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Git报错:error: You have not concluded your merge (MERGE_HEAD exists)</title>
    <url>/2019/05/18/%E8%A7%A3%E5%86%B3Git%E6%8A%A5%E9%94%99-error-You-have-not-concluded-your-merge-MERGE-HEAD-exists/</url>
    <content><![CDATA[<p>Git fetch和git pull的区别:</p>
<a id="more"></a>
<p>都可以从远程获取最新版本到本地<br>1.Git fetch:只是从远程获取最新版本到本地,不会merge(合并)<br>$:git fetch origin master   //从远程的origin的master主分支上获取最新版本到origin/master分支上<br>$:git log -p master..origin/master //比较本地的master分支和origin/master分支的区别<br>$:git merge origin/master          //合并</p>
<p>2.Git pull:从远程获取最新版本并merge(合并)到本地<br>$:git pull origin master  //相当于进行了 git fetch 和 git merge两部操作<br>1<br>实际工作中,可能git fetch更好一些, 因为在merge前,可以根据实际情况决定是否merge<br>再说导致报错:error: You have not concluded your merge (MERGE_HEAD exists).的原因可能是在以前pull下来的代码自动合并失败<br>解决办法一:保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取<br>$:git merge –abort<br>$:git reset –merge<br>$:git pull</p>
<p>解决办法二:舍弃本地代码,远端版本覆盖本地版本(慎重)<br>$:git fetch –all<br>$:git reset –hard origin/master<br>$:git fetch</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/2019/06/01/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>所谓正向代理就是顺着请求的方向进行的代理，即代理服务器他是由你配置为你服务，去请求目标服务器地址。</p>
<p>比如我们要去访问谷歌网站，我们直接访问不通，那么我们就可以找一个代理服务器为我们服务，我们通过代理服务器请求到谷歌网站。对于谷歌而言他只知道有一个服务器访问了自己，并不知道这件事你是访问不了他,找了一个代理服务器访问自己。</p>
<p>在举一个通俗的例子。你需要钱，C正好有钱，但是你C不直接借给你。你和B关系比较好，B可以找C借到钱。你和B沟通后，由B来找C借到钱后在给你。<br>上面的两个例子中的共同特点是 代理服务器和B都是你找到的，为你而服务的，代表你的利益。我们还可以让代理服务器给你代理到推特、Facebook等，他是代理的你。<br><img src="https://img-blog.csdnimg.cn/20190531180703829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhlbmdodWk1MjAx,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>所谓反向代理正好与正向代理相反，代理服务器是为目标服务器服务的，虽然整体的请求返回路线都是一样的都是Client到Proxy到Server。</p>
<p>比如 我们访问百度网站，百度的代理服务器对外的域名为 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 。具体内部的服务器节点我们不知道。现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回。</p>
<p>再举例：我们同样需要钱，但是我们又不知道谁有钱，所以我们找了一家网贷平台，你提交资料后，网贷平台直接将钱打给你。但是你不知道，也不用关注网贷平台的钱从哪里来。网贷平台内部他们可能从哪一个财主哪里融的钱。对你而言网贷平台和他们的金主是一起的。</p>
<p>同样通过上面我们例子可以看到，此时的代理服务器和后面的目标主机是一个系统的（百度公司、网贷平台）。他们是对外提供服务的，所以称为反向代理，代理的是后的人。<br><img src="https://img-blog.csdnimg.cn/20190531180723798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhlbmdodWk1MjAx,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p><strong>正向代理代理的对象是客户端，反向代理代理的对象是服务端</strong></p>
<p>原文链接：<a href="https://blog.csdn.net/liuhenghui5201/article/details/90720442" target="_blank" rel="noopener">https://blog.csdn.net/liuhenghui5201/article/details/90720442</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>解决cannot remove &#39;.user.ini&#39;Operation not permitted</title>
    <url>/2019/04/18/%E8%A7%A3%E5%86%B3cannot-remove-user-ini-Operation-not-permitted/</url>
    <content><![CDATA[<p>在Linux中删除整个git仓库，删除失败出现 cannot remove ‘.user.ini’Operation not permitted，原因就是文件中含有某种属性不可更改，删除该属性就可以了</p>
<a id="more"></a>
<p>在Linux中rm -rf的威力是十分巨大的，特别是附带了 -f 参数，不少新手都干过用root用户执行 rm -rf /命令这种傻事，如果云服务器没有快照，简直就是灾难，从根目录开始所有文件被递归删除，连系统都被损坏。</p>
<p>但是，偶尔也会遇到使用rm -rf也删除不了的文件，执行后报rm: cannot remove `.user.ini’: Operation not permitted，</p>
<p>这时候需要使用到Linux的chattr命令， chattr命令用于改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：<br>a：让文件或目录仅供附加用途。<br>b：不更新文件或目录的最后存取时间。<br>c：将文件或目录压缩后存放。<br>d：将文件或目录排除在倾倒操作之外。<br>i：不得任意更动文件或目录。<br>s：保密性删除文件或目录。<br>S：即时更新文件或目录。<br>u：预防以外删除。<br>语法chattr[-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录…]参数<br>　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。<br>　　-v&lt;版本编号&gt; 设置文件或目录版本。<br>　　-V 显示指令执行过程。<br>　　+&lt;属性&gt; 开启文件或目录的该项属性。<br>　　-&lt;属性&gt; 关闭文件或目录的该项属性。<br>　　=&lt;属性&gt; 指定文件或目录的该项属性。</p>
<p>进入到<code>.user.ini&#39;所在目录，执行一下 lsattr -a，查看文件下下边包含文件的属性，看到</code>.user.ini’有个’i’属性，代表不得任意更动文件或目录，正是此属性在作祟：</p>
<p>然后执行命令：<br><code>chattr -i .user.ini</code><br>就可以去除掉此属性，然后我们再执行删除，就可以顺利删除掉了：</p>
<p>原文链接：<a href="https://blog.csdn.net/sinat_35861727/article/details/79040755" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35861727/article/details/79040755</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
